## 一. 创建对象和方法

**通过关键字 class 来创建类，通过类来创建对象，每个对象拥有类的属性和方法，并且每个对象都是唯一的**

### 1.1 创建类

```java
/**
* 1、创建一个名为Light的类
* 通过class关键字，后面紧跟着的是class的名称
* 类名的首字母必须大写
*/
public class Light {
    // 代码块...
}
```

### 1.2 引用操作对象

**Java 一切都是对象，但我们操作的标识符实际上是对象的一个引用**

![](https://upload-images.jianshu.io/upload_images/2765653-4cc1f87fa296a08d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如果我们想操作 Light ，可以创建一个 Light 的引用：`Light light`

通过这种方式创建的只是引用并不是对象。如果调用 Light 的方法，会返回一个运行时错误，因为此时 light 并没有与任何事物相关联，因此，一种安全的做法是：创建一个引用同时便初始化(就是创建对象)

`Light light = new Light();`

有特殊情况，如果是字符串的话有两种方式：  
1) 可以用带引号的文本初始化 `String s = "asdf"`   
2) 也可以 `String s = new String("asdf");`

```java
/**
* 创建类的对象
*/
public class Test{
    /**
    * 1、创建Light类的对象且名称为：light
    */
    public static void main(String[] args){
        Light light = new Light();
        // 2、调用这个对象的方法
        // 要用引用来操纵对象（就是调用对象的字段和方法）
        light.on(); 
        light.off();
    }
}
```

### 1.3 创建方法

**方法名和参数列表，合起来被成为 “方法签名” 唯一地标识出某个方法**

```
ReturnType methodName(/* Argument list */){
      /*Method body*/
}
```
```java
public class Light {
    /**
    * 2、给Light类添加方法：on()，off()
    * 没有返回值的方法
    * 使用void
    */
    public void on(){
        // 代码块
    }
    // 创建带有参数列表的方法
    public void off(String s1,String s2,String s3){
        // 代码块
    }
}
```

### 1.4 调用带有参数列表方法

参数列表中必须指定每个传递对象类型及名字，像 Java 这种任何传递对象的场合一样，这里传递的实际上也是引用，并且引用的类型必须正确。如果参数被设为String类型，则必须传递一个String对象；否则，编译器会报错

```java

public class Test{
    public static void main(String[] args){ 
        Light light = new Light();
        String s1 = "aa";
        String s2 = "bb";
        String s2 = "cc";
        // 对象调用带有参数列表的方法
        light.off(s1,s2,s3);
        
    }
}
```

### 1.5 调用带有返回值的方法

**return 关键字，包含两方面：**

1. 首先，表示"已经处理完，离开当前方法"。
2. 其次，如果此方法产生了一个值，这个值要放在return关键字后面。 

如果返回类型是 void，return 关键字的作用只是用来退出方法，并且没有必要到方法结束时才离开，可以在任何地方返回

```java
/**
* 创建包含返回值和不包含返回值的方法
*/
public class Light {   
    public void on(){
        // 代码块
    }
    // 没有返回值的方法
    // 使用void
    public void off(String s1,String s2,String s3){
    }
    // 有返回值的方法
    // 使用返回类型，数据类型或引用类型
    public int time(){
        // 代码块
    }
}

public class Test{
    public static void main(String[] args){ 
        Light light = new Light();
        // 要使用返回值类型的时候
        // 返回值的类型必须与x的类型兼容
        int x = light.time();
        light.off(s1,s2,s3);
        
    }
}
```

### 1.6 给类增加字段

**字段（也可以称为数据成员或成员变量）**

字段可以是基本类型也可以引用数据类型，如果是引用数据类型必须初始化该引用

每个对象都有用来存储其字段的空间且不能在对象间共享

```java
/**
* 类型 变量名 = 属性值；
*/
public class Light {
    /**
    * 定义了一个int类型的变量i
    * 且属性值为10
    */
    int i = 10;
    public static void main(String[] args){
        Light light = new Light();
        // 给字段赋值
        // 通过引用对象的成员
        light.i = 47;
    }
}
```

还有一种情况

```java
/**
* 要修改的数据位于当前对象包含的其他对象中
* 这种情况下，只需要再使用连接句点就可以
*/
public class Test{
    Light light = new Light();
    public static void main(String[] args){
        Test test = new Test();
        test.light.i = 50;   
    }

}
```

### 1.7 基本成员默认值

若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获取一个默认值，只有当变量作为类的成员使用时，Java才确保给定其默认值，以确保哪些是基本类型的成员变量得到初始化，防止产生程序错误。

但是要注意的是，如果是局部变量，Java不会给默认值，如果在初始化时没有赋值，编译时会报错


### 1.8 static关键字

当声明一个方法或变量为使用 static 关键字时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。

所以，即使没有创建某个类的任何对象，也可以调用其 static 方法或访问其 static 域

```java
class StaticTest{
    // 创建static域
    static int i = 47;
    // 创建static方法
    static void test(){
        // 代码块
    }
    public static void main(String[] args){
        // 访问静态域和方法的两种方式：
        // 1、一种方式，不需要创建类的对象，直接访问
        int a = StaticTest.i
        // 2、另一种方式，可以创建类的对象，然后通过引用去访问
        // 需要注意的是，就算创建多个对象，所有对象都共享同一个i
        StaticTest staticTest1 = new StaticTest();
        StaticTest staticTest2 = new StaticTest();
        int b = staticTest1.i;
        int c = staticTest1.i;
        // 调用静态方法
        StaticTest.test();
        b.test();
        c.test();
    }
}
```

对于 static 方法还要注意的是：

static 方法（静态方法）就是没有 this 的方法。在 static 方法的内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用 static 方法。

### 1.9 程序的编译与运行

要编译、运行这个程序，首先必须要有一个Java开发环境。安装好的JDK后需要设置classpath，以确保计算机能找到javac和java这两个文件

1. 以上都准备好，将上面完整的程序保存到一个.java为结尾的文件中，并在命令行执行 `javac filename.java`
2. 正常情况下，这行命令不会产生任何响应。然后在命令行继续输入 `java filename`
3. 这之后就可以看到 "Hello World" 输出

![](https://upload-images.jianshu.io/upload_images/2765653-e73b5bf7d9176f00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


### 1.10 JVM、JRE、JDK三者之间的关系

Java通过JVM虚拟机与平台交互，JRE包含JVM

JVM就是一个虚拟的用于执行bytecode字节码的 "虚拟计算机"

JRE包含：Java虚拟机、库函数、运行Java应用程序所必须的文件。运行一个JAVA程序

JDK：包含JRE，以及增加编译器和调试器等用于程序开发的文件。开发Java程序

## 二. 操作符

**在最底层，java中的数据是通过使用操作符来操作的**

1）操作符用于操作数，生成一个新值

2）有些操作符可能会改变操作数自身的值，这被称为 "副作用"，如++ --

当一个String后面紧跟着一个+，而这个+的后面又紧跟一个非String类型的元素时，就会尝试着将这个非String类型的元素转换为String

```java
public class Precedence{
    public static void main(String[] args){
        System.out.println("abc" + 1);
    }
}
```

**赋值操作符 "=" ，它的含义是：将等号右边的值赋值给等号左边的值:**

基本数据类型存储了实际的数值，而非指向一个对象的引用，所以在为其复制的时候，是直接将一个地方的内容复制了另一个地方。对基本数据类型使用a=b，那么b的内容就复制给a。若接着又修改了a，此时b根本不会受这种修改的影响

但对象赋值的时候，要记住的是我们在对一个对象进行操作时，我们真正操作的是对对象的引用。假使将一个对象赋值给另一个对象，实际是将引用从一个地方复制到另一个地方。这意味着假使对象使用c=d，那么c和d都指向的是原本只有d指向的那个对象，此时我们通过b或c来修改原来的对象，b和c调用那个对象返回的值都是最新的。

```java
class tank{
    int level;
}

public class Assignment{
     public static void main(String[] args){
        Tank t1 = new Tank();
        Tank t2 = new Tank();
        t1.level = 9;
        t2.level = 47;
        System.out.println("1 : t1.level: " + t1.level + ", t2.level: " + t2.level);
        t1 = t2;
        System.out.println("2 : t1.level: " + t1.level + ", t2.level: " + t2.level);
        t1.level = 27;
        System.out.println("3 : t1.level: " + t1.level + ", t2.level: " + t2.level);
  }
}
// Output
// 1: t1.level: 9,t2.level: 47
// 2: t1.level: 47,t2.level: 47
// 3: t1.level: 27,t2.level: 27
```

分析：Tank类非常简单，它的两个实例（t1和t2）是在main()方法里创建。对每个Tank类对象都level域都赋予了一个不同的值，然后将t2复制赋值给了t1，由于赋值操作的是一个对象的引用，所以修改t1的同时也改变了t2。这就是因为t1和t2包含的都是相同的引用，他们指向相同的对象。

原本t1包含的对象的引用，是指向一个值为9的对象。在t1赋值的时候，这个引用被覆盖，也就是丢失了；而那个不再被引用的对象会由"垃圾回收器"自动清理了

这种特殊的现象通常称作"别名现象"，是Java操作对象的一种基本方式。在上面的例子中，如果想避免别名问题应该怎么办呢？可以这些写：

```
t1.level = t2.level;
```

这样便可以保持两个对象彼此独立，而不是将t1和t2绑定相同的对象。但直接操作对象内的域容易导致混乱，并且违背了良好的面向对象程序设计的原则。

将一个对象传递给方法时，也会产生别名问题：

```java
// f()传递只是x的引用，所以可以f()之外的对象
class Letter{
  char c;
}

public class PassObject{
    static void f(Letter y){
        y.c = 'z';
  }
    public static void main(String[] args){
        Letter x = new Letter();
        x.c = 'a';
        System.out.println("1: x.c: " + x.c);
        f(x);
        System.out.println("2: x.c: " + x.c);
  }
}

// Output:
// 1: x.c: a;
// 2: x.c: z;
```

一元减号用于转变数据的符号而一元加号(+)只是为了与一元减号(-)相对应，但是它位于的作用仅仅是将较小类型的操作数提升为int（byte，short，char转型为int）

```
x = a * -b; // 编译器能正确识别
x = a * (-b) // 比较明确的写法
```


== 和 != 比较基本类型的是值，也适用于所有对象，比较的就是对象的引用
                                               
**equals() 用来比较两个对象的实际内容是否相同，但这个方法不适用于“基本类型”，基本类型直接使用== 和!=即可**

```java
public class EqualMethod{
    public static void main(String[] args){
        Integer n1 = new Integer(47);
        Integer n2 = new Integer(47);
        System.out.println(n1.equals(n2));
    }
}

// Output
// true
```

**逻辑运算符 与(&&)、或(||)、非(!)能根据参数的逻辑关系，生成一个布尔值(true或false)**

```
public class Bool{
    public static void main(String[] args){
        Random rand = new Random(47);
        int i = rand.nextInt(100);
        int j = rand.nextInt(100);
        System.out.println("i = " + i);
        System.out.println("j = " + j);
        System.out.println("i > j is  " + (i > j));
        System.out.println("i < j is " +  (i < j));
        System.out.println("i >= j is " +  (i >= j));
        System.out.println("i <= j is " +  (i <= j));
        System.out.println("i == j is " +  (i == j));
        System.out.println("i != j is " +  (i != j));
        System.out.println(" (i < 10) && (j < 10) is " +  (i < 10) && (j < 10) ;
        System.out.println(" (i < 10) || (j < 10) is " +  (i < 10) || (j < 10) ;
    }
}

// Output
i = 58
j = 55
i > j is true
i < j is false
i >= j is true
i <= j is false
i == j is false 
i != j is true
(i < 10) && (j < 10) is fasle
 (i < 10) || (j < 10) is fasle

```


**短路一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了**

```java
public class ShortCircuit{
    static boolean test1(int val){
        System.out.println("test1(" + val + ")");
        System.out.println("result : " + (val < 1));
        return val < 1;
    }
     static boolean test2(int val){
        System.out.println("test2(" + val + ")");
        System.out.println("result : " + (val < 2));
        return val < 2;
    }

 static boolean test3(int val){
        System.out.println("test3(" + val + ")");
        System.out.println("result : " + (val < 3));
        return val < 3;
    }

    public static void main(String[] args){
        boolean b = test(0) && test2(2) && test3(2);
        System.out.println("expression is : " + b);
    }
}

// Output
// test1()结果是true，表达式计算会继续下去，test2()结果是false，这意味着整个表达式肯定为false，所以没必要继续计算剩余的表达式。“短路”一词的由来正源于此。事实上。如果所有的逻辑表达式都有一部分不必计算，那将获得潜在的性能提升
// test1(0)
// result:true
// test2(2) 
// result:false
// expression is false
```

**三元操作符也称条件操作符，它比较特别的是有三个操作数；但它确实属于操作符的一种，因为它最终也会生成一个值。**

```
// 如果boolean-exp(布尔表达式)的结果为true，就计算value0，而且这个计算结果也就是操作符最终产生的值。
// 如果boolean-exp的结果为false，就计算value1，同样，它的结果也就成为了操作符最终产生的值
boolean-exp? value0 : value1 
```
                                                    
## 三. 介绍三个关键字：public、private、protected

Java通过三个关键字public、private、protected在类的内部设定边界。这些关键字决定了类的使用范围

这三个关键字可以标识在类、方法、属性的前面

1）public ： 对于任何人都是可用的

2）private ：除类型的创建者和类型的内部方法之外的任何人都不能访问

3）protected ：继承类可以访问

4）一个包访问权限，当没有使用上面任何3个关键字，这个时候，类拥有的就是权限就是，只可以访问同一个包中的其他类的成员。

为了控制类某个类的访问权限，修饰词必须出现于关键字class之前。

类既不可以是private的，也不可以是protected。所有对于类的访问权限，仅有两个选择：包访问权限或public。如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，从而阻止任何人创建该类的对象。但是有一个例外，就是你在该类的static成员内部可以创建。


## 四. 组合的概念

最简单地复用某个类的方式就是直接使用该类的一个对象，另外一种就是将那个类的一个对象置于某个新的类中

新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。这个概念称为"组合" ，组合经常被视为"has-a"（拥有）关系，就像我们常说的"汽车拥有引擎"一样

将某个类的一个对象置于某个新的类中，这个行为可以称为 "创建一个成员对象"，新类的成员对象通常被声明为priate，这使得可以在不干扰使用的情况下， 修改这些成员，也可以在运行时修改这些成员对象，以实现动态修改程序的行为。

```java
class WaterSource{
    private String s;
    WaterSource(){
        System.out.println("WaterSource");
        s = "Constructed";
    }

    public String toString(){
        return s;
    }

}

public class SprinklerSystem {
    private String valve1;
    private String valve2;
    private String valve3;
    private String valve4;

    private WaterSource source = new WaterSource(); // 在SprinklerSystem类中使用 WaterSource类的对象
    private int i;
    private float f;

    @Override
    public String toString() { // 每个非基本类型的对象都有一个toString()方法，当编译器需要一个String而只有1个对象时，这个方法回被调用
        return "SprinklerSystem{" +
                "valve1='" + valve1 + '\'' +
                ", valve2='" + valve2 + '\'' +
                ", valve3='" + valve3 + '\'' +
                ", valve4='" + valve4 + '\'' +
                ", source=" + source + // 这里需要WaterSource的对象source ，当程序执行到这里时，回调用WaterSource的toString()方法，将source转换成一个String
                ", i=" + i +
                ", f=" + f +
                '}';
    }

    public static void main(String[] args) {
        SprinklerSystem sprinklers = new SprinklerSystem();
        System.out.println(sprinklers);
    }
}
/** Output:
WaterSource
SprinklerSystem{valve1='null', valve2='null', valve3='null', valve4='null',source=Constructed, i=0, f=0.0}
*/
```

以上代码执行结果中 ：valve1='null', valve2='null', valve3='null', valve4='null',说明一个问题：类中域为基本类型时能够自动被初始化为零，但是对象引用会被初始化为null。如果想要初始化引用，可以在代码中的下列位置进行：

1）在定义对象的地方，这意味着它们总是能够在构造器被调用之前被初始化

2）在类的构造器中

3）在正要使用这些对象之前，这种方式称为惰性初始化。在生成对象不值得及不必要每次都生成对象的情况下，这种方式可以减少额外的负担

4）使用实例初始化

```java
class Soap{
    private String s;
    Soap(){
        System.out.println("Soap()");
        s = "Constructed";
    }

    @Override
    public String toString() {
        return s;
    }
}
public class Bath {
    private String //在定义处初始化
        s1 = "Happy",
        s2 = "Happy",
        s3,s4;
    private Soap castille;
    private int i;
    private float toy;
    public Bath(){ // 在类的构造器中初始化
        System.out.println("Inside Bath()");
        s3 = "Joy";
        toy = 3.14f;
        castille = new Soap();
    }

    { i =47;} //实例初始化
    public String toString(){
        if(s4 == null){ //惰性初始化
            s4 = "Joy";
        }

        return
                "s1 = " + s1 + "\n" +
                "s2 = " + s2 + "\n" +
                "s3 = " + s3 + "\n" +
                "s4 = " + s4 + "\n" +
                "i = " + i + "\n" +
                "toy = " + toy + "\n" +
                "castille = " + castille;
    }

    public static void main(String[] args) {
        Bath b = new Bath();
        System.out.println(b);
    }
}
```

## 五. 继承

当我们继承现有类时，也就创建了新的类，这个类不仅包括了现有类的所有成员，和方法（现有类中的private成员和方法不可访问）。

因为子类拥有和父类相同的类型，所以，所有发送给父类对象的消息同时也可以发送给子类对象

如果要的父类和子类产生差异，有两种方法：

1）直接在子类添加新方法，这些方法并不是父类接口的一部分

2）覆盖，直接在子类中创建该类的新定义即可 

在上面的两种方式中，直接在子类添加新方法，子类和父类的关系是is-like-a（像是一个）关系，is-a（是一个）关系就是继承中只覆盖基类的方法，而不添加父类中没有的新方法，子类和父类是完全相同的类型。

```java
class Cleanser{ // Cleanser类中的所有方法都必须是public的。这是因为，如果没有加任何访问权限修饰词，那么成员默认的访问权限是包访问权限，它仅允许包内的成员。因此，在此包中，如果没有访问权限修饰词，任何人都可以使用这些方法。但是其他包中的类要从Cleanser中继承，则只能访问public成员，所以，为了继承，一般的规则是将所有的数据成员都指定为private，将所有的方法指定为public
    private String s = "Cleanser";
    public void append(String a){
        s += a; // 使用“+=” 操作符号将String链接成s，此操作符是被Java设计者重载用以处理String对象的操作符之一，另一个是“+”
    }

    public void dilute(){
        append("dilute()");
    }

    public void apply(){
        append(" apply()");
    }

    public void scrub(){
        append(" scrub()");
    }

    @Override
    public String toString() {
        return s;
    }
}

public class Detergent extends Cleanser{

    public void scrub(){ // 覆盖基类的scrub()方法
        append(" Detergent.scrub()");
        super.scrub(); // 调用基类的方法 ，Java用super关键字表示超类的意思，当前类就是从超类继承的。所以super.scrub()将调用基类版本的scrub()方法
    }

    public void foam(){ // 增加新的方法
        append(" foam()");
    }

    public static void main(String[] args) {
        Detergent x = new Detergent();
        x.dilute();
        x.apply();
        x.scrub();
        x.foam();
        System.out.println(x);
        System.out.println("Testing base class;");
    }
}
```

### 5.1 初始化父类

当创建一个子类的对象时，该对象包含了一个父类的子对象。这个子对象与用父类直接创建的对象是一样的。而且区别在于，后者来自于外部，而父类的子对象被包装在子类对象内部

因此，对父类子对象的正确初始化也是至关重要，而且也仅有一种方法来包中这一点：在构造器中调用父类构造器来执行初始化，而父类构造器具有执行父类初始化的能力。Java会自动在子类中构造器中插入对父类构造器的调用

```java
class Art{
    Art(){
        System.out.println("Art constructor");
    }
}

class Drawing extends Art{
    Drawing(){
        System.out.println("Drawing constructor");
    }
}

public class Cartoon extends Drawing{

    public Cartoon(){
        System.out.println("Cartoon constructor");
    }

    public static void main(String[] args) {
        Cartoon x = new Cartoon();
    }
}
/** 执行结果 : 通过结果会发现，构建过程是从父类“向外”扩散的，所以父类在子类构造器可以访问它之前，就已经完成了初始化了。即使不为Cartoon()创建构造器，编译器也会为你合成一个默认的构造器，该构造器将待用父类的构造器
Art constructor
Drawing constructor
Cartoon constructor
*/
```

### 5.2 带参数的构造器

如果没有默认的父类构造器，或者想调用一个带参数的父类构造器，就必须用关键字super显式地编写调用父类构造器的语句，并且配以适当的参数列表

```java
class Game{
    Game(int i){
        System.out.println("Game constructor");
    }
}

class BoardGame extends Game{
    BoardGame(int i){
        super(i);
        System.out.println("BoardGame constructor");
    }
}
public class Chess extends BoardGame{
    Chess(){
        super(11); // 必须要在子类中调用父类的带参数的构造器
        System.out.println("Chess constructor");
    }

    public static void main(String[] args) {
        Chess x = new Chess();
    }
}
```

最后，还要注意的是，当创建一个类时，总是在继承，因此，除了已明确指出要从其他类中继承，否则就是在隐式地从Java的标准
根类Object进行继承

### 5.3 继承中的重载机制

如果Java的父类拥有某个已被多次重载的方法名称，那么在子类中重新定义该方法名称并不会屏蔽其在父类中的任何版本。因此，无论在子类或者它的父类中对方法进行定义，重载机制都可以正常工作

```java
class Homer{
    char doh(char c){
        System.out.println("doh(char)");
        return 'd';
    }
    
    float doh(float f){
        System.out.println("doh(float)");
        return 1.0f;
    }
}

class Milhouse{}

class Bart extends Homer{
    void doh(Milhouse m){
        System.out.println("doh(Milhouse)");
    }
}
public class Hide {
    public static void main(String[] args) {
        Bart b = new Bart();
        b.doh(1);
        b.doh('x');
        b.doh(1.0f);
        b.doh(new Milhouse());
    }
}
```

从上述例子中，可以看到，虽然 Bart 引入了一个新的重载方法，但是 Bart 中 Homer 的所有重载方法都是可用的。使用与基类完全相同的特征签名及返回类型来覆盖具有相同名称的方法，是一件极其平常的事。

JavaSE5新增加了 @Override 注解，它并不是关键字，但是可以把它当作关键字使用，当你想要覆盖某个方法时，可以选择添加这个注解，但不小心重载而并非覆盖了该方法时，编译器就会生成一条错误消息。

### 5.4 在组合与继承之间选择

组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形。即，在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。为取得此效果，需要在新类中嵌入一个现有类的private对象

在继承的时候，使用某个现有类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。通常用“is-a”(是一个)的关系是用继承来表达的，而“has-a”(又一个)的关系则用组合来表达的

### 5.5 向上转型

继承除了为新的类提供方法，还有重要的方面是用来表现子类和父类之间的关系。这种关系可以用“新类是现有类的一种类型”这句话加以概括。

```java
class Instrument{
    public void play(){}
    static void tune(Instrument i){
        i.play();
    }
}
public class Wind extends Instrument{
    public static void main(String[] args) {
        Wind flute = new Wind();
        Instrument.tune(flute);  // flute是 Instrument子类Wind的对象，tune()方法可以接受Instrument引用，这里将Wind对象传递给tune()，由于Java对类型的检查十分严格，这里Wind对象同样也是一种Instrument对象，在tune()中，程序代码可以对Instrument和它所有的子类起作用，这种将Wind引用转换为Instrument引用的动作，称之为向上转型
    }
}
```

flute 是 Instrument 子类 Wind 的对象，tune() 方法可以接受 Instrument 引用，这里将 Wind 对象传递给 tune()，由于 Java 对类型的检查十分严格，这里 Wind 对象同样也是一种 Instrument 对象，在 tune() 中，程序代码可以对 Instrument 和它所有的子类起作用，这种将 Wind 引用转换为 Instrument 引用的动作，称之为向上转型

**为什么称为向上转型**

传统的类继承图的绘制方法：将根置于页面的顶端，然后逐渐向下：

![Wind.java的继承图](https://upload-images.jianshu.io/upload_images/2765653-1447fc8b0b479fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

由子类转型成父类，在继承图上是向上移动的，因此一般称为向上转型。由于向上转型是从一个较专用类型向通用类型转换，所以总是很安全的。也就是说，子类就是父类的一个超集。子类可能比父类含有更多的方法，但它必须至少具有基类中所含有的方法。

## 六. 代理

除了组合和继承，还有一种可以复用类就是使用代理，Java并没有提供对它的直接支持。这是继承与组合之间的中庸之道，因为我们将一个成员对象置于所要构造的类中（就像组合），但于此同时我们在新类中暴露了该成员对象的所有方法（就像继承）

```java
public class SpaceShipControls {
    void up(int velocity){}
    void down(int velocity){}
    void left(int velocity){}
    void right(int velocity){}
    void forward(int velocity){}
    void back(int velocity){}
    void turboBoost(){}
}
```

```java
public class SpaceShipDelegation {
    private String name;
    private SpaceShipControls controls = new SpaceShipControls();
    public SpaceShipDelegation(String name){
        this.name = name;
    }

    public void back(int velocity){
        controls.back(velocity);
    }

    public void dowm(int velocity){
        controls.down(velocity);
    }

    public void forward(int velocity){
        controls.forward(velocity);
    }

    public void left(int velocity){
        controls.left(velocity);
    }

    public void right(int velocity){
        controls.right(velocity);
    }

    public void turboBoost(){
        controls.turboBoost();
    }

    public void up(int velocity){
        controls.up(velocity);
    }

    public static void main(String[] args) {
        SpaceShipDelegation protector = new SpaceShipDelegation("NSEA Protector");
    }
}
```

## 七. final 关键字

final 会使用到的三种情况：数据、方法和类

final 数据：

1) 一个永不改变的编译时常量

2) 一个在运行时被初始化的值，而你不希望它被改变

对于编译期常量这种情况，在Java中，这类常量必须是基本数据类型，以关键字final修饰。在对这个常量进行定义的时候，必须对其进行赋值。

一个既是 static 又是 final 的域只占据一段不能改变的存储空间，用大写表示，并使用下划线分隔各个单词

当是对象引用而不是基本类型时，对于基本类型，final 使数值恒定不变；

对于对象引用，final 使引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。但对象自身是可以被修改的。Java并未提供任何使对象恒定不变的途径。

这样的限制同样适用数组，它也是对象

```java
class Value{
    int i;
    public Value(int i){
        this.i = i;
    }
}
public class FinalDate {
    private static Random rand = new Random(47);
    private String id;
    public FinalDate(String id){
        this.id = id;
    }

    private final int valueOne = 9; // 编译时常量
    private static final int VALUE_TWO = 99; // 公共常量

    public static final int VALUE_THREE = 39; // 公共常量

    private final int i4 = rand.nextInt(20); // 不能是编译时常量

    static final int INT_5 = rand.nextInt(20); // 不能是编译时常量

    private Value v1 = new Value(11);

    private final Value v2 = new Value(22); // final修饰对象

    private static final Value VAL_3 = new Value(33); // static final修饰对象

    private final int[] a = {1,2,3,4,5,6}; //final修饰数组

    public String toString(){
        return id + ": " + "i4 = " + i4 + ", INT_5 = " + INT_5;
    }

    public static void main(String[] args) {
        FinalDate fd1 = new FinalDate("fd1");
       // fd1.valueOne++; // 不能修改值，因为final修饰
        fd1.v2.i++; // 可以修改对象自身的值
        fd1.v1 = new Value(9); // 不是final指定的
        for(int i = 0; i < fd1.a.length;i++){
            fd1.a[i]++; // 可以修改数组内部的值
        }

       //fd1.v2 == new Value(0); // 不能给v2重新赋值新的对象
        //fd1.VAL_3 = new Value(1); // 不能重新赋值
        //fd1.a = new int[3]; // 不能重新赋值

        System.out.println(fd1);
        System.out.println("Creating new FinalDate");
        FinalDate fd2 = new FinalDate("fd2");
        System.out.println(fd1);
        System.out.println(fd2);
    }
}
```

valueOne 和 VAL_TWO 都是带有编译时数值的 final 基本类型，可以用作编译期常量
VAL_THREE 是一种更加典型的对常量进行定义的方式：定义为 public，则可以被用于包之外；定义为 static，则强调只有一份；定义为 fianl，则说明它是一个常量。
i4 和 INT_5 说明了不能因为某数据是 final 的就认为在编译时可以知道它的值。i4 和 INT_5 也展示了 final 数值定义为静态和非静态的区别，在 fd1 和 fd2 中，i4 的值是唯一的并且每次创建对象初始化的值是不同的，但 INT_5 的值是不可以通过创建第二个 FinalData 对象而加以改变的，此区别只有当数值在运行时内被初始化时才会显现。
v1、v2、VAL_3 说明了 final 引用的意义。由于 v2 是 final 的，就认为无法改变它的值。由于它是一个引用，final 意味着无法将 v2 再次指向另一个新的对象。这对数组具有同样的意义，数组只不过是另一种引用。

### 7.1 空白 final

Java 允许生成“空白 final ”，所谓空白 final 是指被声明为 final 但又没有给定初值的域。必须在域的定义处或者每个构造器中用表达式对 final 进行赋值

```java
class Poppet{
    private int i;
    Poppet(int i){
        this.i = i;
    }
}
public class BlankFinal {
    private final int i = 0;
    private final int j;
    private final Poppet p;
    public BlankFinal(){
        j = 1;
        p = new Poppet(1);
    }
    
    public BlankFinal(int x){
        j = x;
        p = new Poppet(x);
    }

    public static void main(String[] args) {
        new BlankFinal();
        new BlankFinal(47);
    }
}
```

### 7.2 final 参数

Java 允许在参数列表中以声明的方式将参数指明为 final。这意味着你无法在方法中更改参数引用所指向的对象：

```java
class Gizmo{
    public void spin(){}
}
public class FinalArguments {
    void with(final Gizmo g){
       //  g = new Gizmo(); // 无法修改参数引用所指向的对象
    }
    void without(Gizmo g){
        g = new Gizmo();
        g.spin();
    }
    
    void f(final int i){ // 展示了当基本类型的参数被指明为final时所出现的结果：你可以读参数，但却无法修改参数。这一特性主要用来向匿名内部类传递数据
        //i++; // 不能修改
    }
    
    int g(final int i){
        return i + 1;
    }

    public static void main(String[] args) {
        FinalArguments bf = new FinalArguments();
        bf.without(null);
        bf.with(null);
        
    }
}
```

### 7.3 final 方法

类中所有的 private 方法都隐式地指定为是 final 的。由于无法取用 private 方法，所以也就无法覆盖它。可以对 private 方法添加 final 修饰词，但这并不能给该方法增加任何额外的意义

```java
class WithFinals{
    private final void f(){
        System.out.println("WithFinals.f()");
    }

    private void g(){
        System.out.println("WithFinals.g()");
    }
}

class OverridingPrivate extends WithFinals{
    private final void f(){
        System.out.println("OverridingPrivate.f()");
    }
    private void g(){
        System.out.println("OverridingPrivate.g()");
    }
}

class OverridingPrivate2 extends OverridingPrivate{
    public final void f(){
        System.out.println("OverridingPrivate2.f()");
    }

    public void g(){
        System.out.println("OverridingPrivate2.g()");
    }
}
public class FianlOverridingIllusion {
    public static void main(String[] args) {
        OverridingPrivate2 op2 = new OverridingPrivate2();
        op2.f();
        op2.g();

        OverridingPrivate op = op2;
        WithFinals wf = op2;
    }
}
```

覆盖只有在某方法是基类的接口的一部分时才会发现。即，必须能将一个对象向上转型为它的基本类型并调用相同的方法。如果某方法为 private，它就不是父类接口的一部分，仅是一些隐藏于类中的程序代码，只不过是具有相同的名称而已。但如果在子类中以相同的名称生成一个 public、protected 或包访问权限方法的话，该方法就不会产生在父类中出现的“仅具有相同名称”的情况， 此时，并没有覆盖该方法，仅是生成了一个新的方法

### 7.4 final类

当将某个类的整体定义为 final 时，就表明这个类不能被继承

```java
class SmallBrain{}

final class Dinosaur{
    int i = 7;
    int j = 1;
    SmallBrain x = new SmallBrain();
    void f(){}
}
public class Jurassic {
    public static void main(String[] args) {
        Dinosaur n = new Dinosaur();
        n.f();
        n.i = 40;
        n.j++;
    }
}
```

final 域可以根据的个人的意愿选择是或不是 final，不论类是否被定义为 final，相同的规则都适用于定义为final域。然而，由于 final 类禁止继承，所以 final 了中所有的方法都隐式的指定为是 final 的，因为无法覆盖它们。在 final 类中可以给方法添加 final 修饰词，但这不会增加任何意义。

### 7.5 继承中的初始化及类的加载

在 Java 中的所有事物都是对象，每个类的编译代码都存在于它自己的独立的文件中。该文件只在需要使用程序代码时才会被加载。

一般来说，可以说"类的代码在除此使用时才会加载"，这通常是指加载发生于创建类的第一个对象时，但是当访问 static 域或 static 方法时，也会发生加载。

所有的 staic 对象和 staic 代码段都会在加载时依程序中的顺序（即，定义类时的书写顺序）而依次初始化。

```java
class Insect{
    private int i = 9;
    protected int j;
    Insect(){
        System.out.println("i = " + i + ", j = " + j);
        j = 39;
    }

    private static int x1 = printInit("static Insect.x1 initialized");
    static int printInit(String s){
        System.out.println(s);
        return 47;
    }
}
public class Bettle extends Insect{
    private int k = printInit("Beetle.k initialized");
    public Bettle(){
        System.out.println("k =  " + k);
        System.out.println("j =  " + j);
    }

    private static int x2 = printInit("static Beetle.x2 initialized");

    public static void main(String[] args) {
        System.out.println("Beetle constructor");
        Bettle b = new Bettle();
    }
}
/**
执行结果：
static Insect.x1 initialized // 父类的静态方法被调用，在创建对象前
static Beetle.x2 initialized // 子类的静态方法被调用，在创建对象前
Beetle constructor // main()方法开始执行
i = 9, j = 0 // 父类的构造器执行，在此之前，父类的字段初始化，没有赋值的基本类型被置为默认值，对象应用被设为 null，
Beetle.k initialized // 子类的字段初始化
k =  47 // 子类的构造器执行
j =  39
*/
```

在 Bettle 类上运行 Java 时，所发生的第一件事情就是访问 Bettle.main()（一个static），于是加载器开始启动并找出Bettle类的编译代码（在名为Bettle.class的文件之中）。在对它进行加载的过程中，编译器注意到它有一个父类（通过由关键字extends得知的），于是它继承进行加载。不管你是否打算产生一个父类的对象，这都要发生。

如果该父类还有其自身的父类，那么第二个父类就会被加载，如此类推。接下来，根父类中的static初始化（Insect类）即会被执行，然后是下一个子类，以此类推。这种方式很重要，因此子类的static初始化可能会依赖于父类成员能否被正确初始化

至此为止所有的类都加载完毕，对象就可以创建了。首先，对象中所有的基本类型都会被设为默认值，对象引用被设为null--这是通过将对象内存设为二进制而一句生成的。然后，父类的构造器会被调用。在生疏例子中，它是被自动调用的。但也可以用super来指定对父类类构造器的调用。

## 八. 多态

面向对象的程序设计语言的三大特征是：抽象、继承、多态
 
封装通过合并特征和行为来创建新的数据类型。
 
实现隐藏则通过将私有化把接口和实现分离。

多态的作用是消除类型之间的耦合关系。

继承允许将对象视为它自己本身的类型或其父类型来加以处理。允许将多种类型（从同一父类继承的）视为同一类型来处理。

多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一父类继承而来的。这种区别是根据方法行为的不同而表现出来的，虽然这些方法都可以通过同一父类来调用

### 10.1 再论向上转型

对象既可以作为它自己本身的类型使用，也可以作为它的父类型使用。而这种把某个对象的引用视为对其父类型的引用的做法被称作向上转型

```java
class Instrument{
    public void play(Note n){
        System.out.println("Instrument.play()");
    }
}
public class Wind extends Instrument{
    public void play(Note n){
        System.out.println("Wind.play() " + n);
    }
}
```

```java
public class Music {
    public static void tune(Instrument i){ // 接受一个Instrument 引用，同时也接受任何Instrument的子类
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Wind flute  = new Wind();
        tune(flute);
    }
}
```

```java
public enum Note {
    MIDDLE_C,C_SHARP,B_FLAT;
}
```

### 10.2 方法调用绑定

将一个方法调用和一个方法主体关联起来被称作绑定。

在上面的代码中，因为编译器只有1个Instrument引用时，它无法知道究竟调用哪个方法，解决的方法就是后期绑定，后期绑定的含义就是在运行时根据对象的类型进行绑定。后期绑定也叫做动态绑定或运行时绑定。也就是说，编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。


![继承图](https://upload-images.jianshu.io/upload_images/2765653-65e84649cfcdd5bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

向上转型可以像下面这条语句这么简单：```Shape s = new Circle();```

此时调用父类方法（父类方法已经在子类中被覆盖）：```s.draw();```，由于后期绑定（多态），还是正确调用了```Circle.draw()```方法

![](https://upload-images.jianshu.io/upload_images/2765653-e970269bf2686a48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```java
package com.testya.test;

class Instrument{
    void play(Note n){
        System.out.println("Instrument.play() " + n);
    }
    String what(){
        return "Instrument";
    }

    void adjust(){
        System.out.println("adjusting instrument");
    }
}

class Wind extends Instrument{
    void play(Note n){
        System.out.println("Wind.play() " + n);
    }
    String what(){
        return "Wind";
    }

    void adjust(){
        System.out.println("adjusting Wind");
    }
}

class Percussion extends Instrument{
    void play(Note n){
        System.out.println("Percussion.play() " + n);
    }
    String what(){
        return "Percussion";
    }

    void adjust(){
        System.out.println("adjusting Percussion");
    }
}

class Stringed extends Instrument{
    void play(Note n){
        System.out.println("Stringed.play() " + n);
    }
    String what(){
        return "Stringed";
    }

    void adjust(){
        System.out.println("adjusting Stringed");
    }
}

class Brass extends Wind{
    void play(Note n){
        System.out.println("Brass.play() " + n);
    }
    void adjust(){
        System.out.println("adjusting Brass");
    }
}

class Woodwind extends Wind{
    void play(Note n){
        System.out.println("Woodwind.play() " + n);
    }
    void adjust(){
        System.out.println("adjusting Woodwind");
    }
}
public class Music3 {
    public static void tune(Instrument i){
        i.play(Note.MIDDLE_C);
    }

    public static void tuneAll(Instrument[] e){
        for(Instrument i : e){
            tune(i);
        }
    }

    public static void main(String[] args) {
        Instrument[] Orchestra = {new Wind(),new Percussion(),new Stringed(),new Brass(),new Woodwind()};
        tuneAll(Orchestra);
    }
}
```

```java
public enum Note {
    MIDDLE_C,C_SHARP,B_FLAT;
}
```

### 10.3 域和静态方法
    
```java
class Super{
    public int field = 0;
    public int getField(){
        return field;
    }
}

class Sub extends Super{
    public int field = 1;
    public int getField(){
        return field;
    }
    public int getSuperField(){
        return super.field;
    }
}
public class FieldAccess {
    public static void main(String[] args){
        Super sup = new Sub();
        System.out.println("sup.field = " + sup.field + " , sup.getField() = " + sup.getField());

        Sub sub = new Sub();
        System.out.println("sub.field = " + sub.field + " , sub.getField() = " + sub.getField() + " , sub.getSuperField() = " + sub.getSuperField());
    }
}
```

当Sub对象转型为Super引用时，任何域访问操作都将由编译器解析，因此不是多态的。在上面的例子中，为Super.field和Sub.field分配了不同的存储空间。这样，Sub实际上包含两个称为field的域：它自己的和它从Super处得到的。然而在引用Sub中的field时所产生默认域并非Super版本的field域。因此，为了得到Super.field，必须显式地指明super.field。在实际开发中，首先要将所有的域设置成private，因此不能直接访问它们，其副作用是只能调用方法来访问。另外，不要对父类中的域和子类中的域赋予相同的名字，因为这种做法容易令人混淆

如果某个方法是静态的，它的行为就不具有多态性：静态方法是与类，而并非与单个对象相关联的

```java
class StaticSuper{
    public static String  staticGet(){
        return "Base staticGet()";
    }

    public String dynamicGet(){
        return "Base dynamicGet";
    }
}

class StaticSub extends StaticSuper{
    public static String  staticGet(){
        return "Derived staticGet()";
    }

    public String dynamicGet(){
        return "Derived dynamicGet";
    }
}
public class StaticPolymorphism {
    public static void main(String[] args) {
        StaticSuper sup = new StaticSub();
        System.out.println(sup.staticGet());
        System.out.println(sup.dynamicGet());
    }
}
```

### 10.4 构造器和多态

构造器实际上是static方法，只不过该static声明是隐式的，所以构造器并不具有多态性

**构造器在多态的层次结构中的调用顺序**
  
子类构造过程中调用父类的构造器，而且是按照继承层次逐渐向上链接，以使每个父类的构造器都能得到调用。这样做的原因是：因为构造器的重要任务之一是：检查对象是否被正确地构造，子类只能访问它自己的成员，不能访问父类的成员（父类成员通常是private的）。所以只有父类才能正确的初始化。因此所有的构造器都必须得到调用。在子类的构造器中，如果没有明确指定调用某个父类构造器，子类构造器会自动调用默认构造器，如果不存默认构造器，编译器就会报错（若某个类没有构造器，便器会自动合成出一个默认构造器）

```java
class Meal{
    Meal(){
        System.out.println("Meal()");
    }
}

class Bread{
    Bread(){
        System.out.println("Bread()");
    }
}

class Cheese{
    Cheese(){
        System.out.println("Cheese()");
    }
}

class Lettuce{
    Lettuce(){
        System.out.println("Lettuce()");
    }
}

class Lunch extends Meal{
    Lunch(){
        System.out.println("Lunch()");
    }
}

class PortableLunch extends Lunch{
    PortableLunch(){
        System.out.println("PortableLunch()");
    }
}


public class Sandwich extends PortableLunch{
    private Bread b = new Bread();
    private Cheese c = new Cheese();
    private Lettuce l = new Lettuce();
    public Sandwich(){
        System.out.println("Sandwich()");
    }

    public static void main(String[] args) {
        new Sandwich();
    }
}
/** 执行结果：
Meal()
Lunch()
PortableLunch()
Bread()
Cheese()
Lettuce()
Sandwich()
*/
```

上面的例子中，每个类都有构造器，并且Sandwich体现了三层继承关系以及三个成员对象。当在main()方法里创建Sandwich()对象后，就可以看到输出结果：

1）先调用父类的构造器，这个步骤会不断的反复递归下去，首先是Meal类，然后是下一层子类Lunch，最后是PortableLunch

2）按声明顺序调用Sandwich成员的初始化方法

3）调用Sandwich构造器

### 10.5 构造器内部的多态方法

在一般的方法内部，动态绑定的调用是在运行时才决定的，因为对象无法知道方法所在的那个类，还是属于那个类的子类

如果要调用的构造器内部的一个动态绑定方法，就是用到那个方法的被覆盖后的定义，这个调用的效果可能相当难以预料，因此被覆盖的方法在对象被完全构造之前就会被调用。

```java
class Glyph{
    void draw(){
        System.out.println("Glyph.draw()");
    }

    Glyph(){
        System.out.println("Glyph() before draw()");
        draw();;
        System.out.println("Glyph() after draw()");
    }
}

class RoundGlyph extends Glyph{
    private int radius = 1;
    RoundGlyph(int r){
        radius = r;
        System.out.println("RoundGlyph.RoundGlyph(),radius = " + radius);
    }
    
    void draw(){
        System.out.println("RoundGlyph.draw(),radius = " + radius);
    }
}
public class PloyConstructors {

    public static void main(String[] args) {
        new RoundGlyph(5);
    }
}
```

在上面的例子中，Glyph.draw()方法设计为被覆盖，这种覆盖是在RoundGlyph发生的。但是Glyph构造器会调用这个方法，结果导致了对RoundGlyph.draw()的调用。但是从输出结果看，此时radius不是默认初始值1，而是0

所以，初始化的实际过程是：

1）在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零

2）如前所述那样调用父类的构造器。此时，调用被覆盖后的draw()方法（在RoundGlyph构造器之前调用），由于步骤1的缘故，此时发现radius的值为0

3）按照声明的顺序调用成员的初始化方法

4）调用子类的构造器主体

因此，编译构造器时有一条有效的准则：用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法。在构造器中唯一能够安全调用的那些方法是父类中的final方法（也适用于private方法，它们自动属于final方法，这些方法不能被覆盖）

### 10.6 协变返回类型

JavaSE5 中添加了协变返回类型，它表示在子类中的被覆盖的方法可以返回父类方法的返回类型的某种子类类型

```java
class Grain{
    public String toString(){
        return "Grain";
    }
}

class Wheat extends Grain{
    public String toString(){
        return "Wheat";
    }
}

class Mill{
    Grain process(){
        return new Grain();
    }
}

class WheatMill extends Mill{
    Wheat process(){
        return new Wheat();
    }
}
public class CovariantReturn {
    public static void main(String[] args) {
        Mill m = new Mill();
        Grain g = m.process();
        System.out.println(g);
        m = new WheatMill();
        g = m.process();
        System.out.println(g);
    }
}
```

### 10.7 用继承进行设计

```java
class Actor{
    public void act(){}
}

class HappyActor extends Actor{
    public void act(){
        System.out.println("HappyActor");
    }
}

class SadActor extends Actor{
    public void act(){
        System.out.println("SadActor");
    }
}

class Stage{
    private Actor actor = new HappyActor();
    public void change(){
        actor = new SadActor();
    }
    
    public void performPlay(){
        actor.act();
    }
}
public class Transmogrify {
    public static void main(String[] args) {
        Stage stage = new Stage();
        stage.performPlay();
        stage.change();
        stage.performPlay();
    }
}
```

在上面的例子中：Stage对象包含一个对Actor的引用，而Actor被初始化为
HappyActor对象。这意味着performPlay()会产生某种行为，并且SadActor对象的引用可以在actor中被替代，performPlay()产生的行为也随之改变。这样一来，我们在运行期间获得了动态灵活性（这也称作状态模式）

通常：用继承表达行为间的差异，用字段表达状态上的变化。在上述例子汇总，两者都用到了：通过继承得到了两个不同的类，用于表达act()方法的差异，而Stage通过运用组合使自己的状态发生变化。在这种情况下，状态的改变也就产生了行为的改变。

### 10.8 纯继承域扩展

用纯继承的方式创建继承层次结构，也就是说，只有在父类中已经建立的方法才可以在导出类中被覆盖。这种被称作是纯碎的is-a(是一种)关系，因为一个类的接口已经确定了它应该是什么。继承可以确保所有子类具有父类的接口，且绝对不会少。在使用中子类可以完全替代父类，而且使用子类时，完全不需要知道关于子类的任何额外信息，因为父类可以接受发送给子类的任何消息，由于二者有完全相同的接口，我们只需从子类向上转型，用于不需要正在处理的对象的确切类型。所有这一切，都是通过多态来处理的

但是在实际开发中，扩展接口才是解决特定问题的完美方案。这可以在称为“is-like-a”(像一个)关系，因为子类就像是一个父类-拥有父类相同的基本接口，但是子类还可以具有额外方法实现的其他特性

但这种方式也具有其缺点，就是子类的部分接口是不能被父类访问的，这时，一旦向上转型，就不能调用子类中父类中并没有定义的那些方法

### 10.9 向下转型与运行时类型识别

在Java中，所有的转型都会得到检查！所以即使我们只是进行一次普通的加括号形式的类型转换，在进入运行期时仍然会对其进行检查，以保证它的确是我们希望的哪种类型，否则，如果不是，就会返回一个ClassCastException（类转型异常），这种在运行期间对类型进行检查的行为称作“运行时类型识别”（RTTI）

```java
class Useful{
    public void f(){}
    public void g(){}
}

class MoreUseful extends Useful{
    public void f(){}
    public void g(){}
    public void u(){}
    public void v(){}
    public void w(){}
}
public class RTTI {
    public static void main(String[] args) {
        Useful[] x = {new Useful(),new MoreUseful()};
        x[0].f();
        x[0].g();
        ((MoreUseful)x[1]).u(); // RTTI 向下转型
        // ((MoreUseful)x[0]).u();  // ClassCastException ，Useful对象不能转型为MoreUseful
    }
}
```

## 九. 后期绑定、向上转型的概念

在处理类型的层次结构时，经常把一个对象不当作它所属的特定类型的对象，而是将其当作其父类的对象。这就称为"泛化"，这样可以编写出不依赖特定类型的代码

使用泛化将会产生一个问题，但我们将子类当作父类来看待时，会存在一个问题，编译器在编译时是不可能知道
自己哪一段代码将被执行，那对象如何根据自身的具体类型来执行相应的代码呢？

在下面的图中，BirdController对象仅仅处理泛化的Bird对象，而不了解它们的确切类型。
从BirdController的角度看，这么做非常方便，因为不需要编写特别的代码来判定要处理的Bird对象的确切类型或其行为。
当move()方法被调用时，即便忽略Bird的具体类型，也会产生正确的行为（Goose（鹅）会走、非或游泳，Penguin（企鹅）走或游泳），

这是如何发生的呢？

![](https://upload-images.jianshu.io/upload_images/2765653-ffe0e926f8e5be21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

所以为了解决这个问题，**面向对象程序设计语言使用了后期绑定的概念**。当向对象发送消息时，被调用
的代码直到运行时才能确定。编译器在编译时确保被调用方法的存在，并对调用参数和返回值执行类型检查，
但是并不直到将被执行的确切代码。

**为了执行后期绑定，Java使用了一段特殊的代码替代绝对地址调用。这段代码使用在对象存储的信息来计算方法体的地址。**
这样，根据这一小段代码的内容，每个对象都可以具有不同的行为表现，当向一个对象发送消息时，该对象就能知道对这条消息应该做些什么。
**在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态**

**向上转型：因为动态绑定，所以发送给父类的任何消息，子类都可以接收，那么将子类看作是它的父类的过程称为向上转型。**

![](https://upload-images.jianshu.io/upload_images/2765653-5d1bce38758271cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


```java
/**
* 编写方法，接收一个父类类型作为参数
**/
public class Test{
    void doSomething(Shape shape){
        shape.erase();
        shape.draw();
    }
    public static void main(String[] args){
      Circle circle = new Circle(); // 创建子类对象
      Triangle triangle = new Triangle(); 
      Line line = new Line();
      doSomthing(circle); // 调用doSomething()并将子类作为参数传进去
      doSomthing(triangle);
      doSomthing(line);
    }
}   
```

对doSomthing()的调用会自动地正确处理，而不管对象的确切类型，比如```doSomthing(circle);```  由于Circle可以被doSomething()看作是Shape，也就是说，doSomthing()可以发送给Shape的任何消息，Circle也可以接收。

## 十. Object类

在Java中所有的类最终都继承自单一的基类，这个类就是Object，这称为单根继承结构

在单根继承结构中的所有对象都具有一个共有接口，所以它们归根到底都是相同的基本类型。
 
单根继承结构保证所有的对象都具有某些功能。所有对象都可以很容易地在堆上创建，而参数传递也得到了极大的简化；并且使垃圾回收器变得容易得多（垃圾回收器正是Java相对C++的重要改进之一） 

## 十一. 存储位置

1）寄存器 最快的存储区，位于处理器内部。寄存器的数量极其优先，所以寄存器根据需求进行分配，不能直接控制，在程序中也不能感觉到寄存器存在的任何迹象

2）堆栈 位于RAM（随机访问存储器）中，可以通过堆栈指针从处理器获取直接支持。堆栈指针向下移动，则分配新的内存；向上移动，则释放哪些内存。这是一种仅次于寄存器的有效的分配存储方法。对象引用存储在堆栈中

3）堆 一种通用的内存池，位于RAM中，用于存放所有的Java对象

4）常量存储 常量值通常直接存放在程序代码内部。

5）非RAM存储 数据完全存活于程序之外，可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是流对象和持久化对象。流对象中，对象转化成字节流，通常被发送给另一台机器。持久化对象中，对象被存放于磁盘上。这种存储方式的技巧在于：把对象转化成可以存放在其他媒介上的事物，在需要时，可恢复成常规的、基于RAM的对象

## 十二. 数据类型

数据类型包含两种：基本数据类型和引用数据类型
 
整数类型四种表示形式：十进制 、八进制 以0开头、二进制 0b或0B开头、十六进制 0x或0X开头

浮点类型两种表示形式：十进制数形式、科学记数法形式 
  
![](https://upload-images.jianshu.io/upload_images/2765653-5be4860ad470d9bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Java中一般通过new创建对象并将对象存储在“堆”里，并通过变量引用保存对象的地址，而对于基本类型，需要特殊对待，基本类型不用new来创建变量，而是创建一个并非是引用的“自动”变量。这个变量直接存储的是“值”，并置于堆栈中，因此更加高效

Java会确定每种基本类型所占存储空间的大小，并且这个大小并不会随着机器硬件架构的变化而变化。这也成为了Java比其他大多数语言编写的程序更具移植性的原因之一

![](https://upload-images.jianshu.io/upload_images/2765653-bde027253732542f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1个字节占8bits，所以

![](https://upload-images.jianshu.io/upload_images/2765653-aa40d1900172a433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

float单精度类型，尾数精确到7位，double双精度类型，尾数精确到14位
 
float和double不适合在不容许舍入误差的金融计算领域，如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal
  
folat类型的数值后面要有一个后缀F或f，没有的默认为double类型，也可以在数值后添加后缀D或者d，明确double类型

BigInteger可以准确的表示任何大小的整数值，而且不会丢失任何消息
 
BigDecimal支持任何精度的浮点数，例如，可以用它进行精确的货币计算

## 十三. 作用域

作用域决定了在其内定义的明亮名的可见性和生命周期，**在Java中，作用域由花括号的位置决定**

### 13.1 基本类型的作用域

```java

public class Test{
    {int x = 12;
    // Only x available
        {
        int q = 96;
        // Bath x & q available
        }
    // Only x available
    // q is "out of scope"
    }
}
```

### 13.2 对象的作用域

Java对象不具备和基本类型一样的生命周期，当用new创建一个Java对象时，它可以存活于作用域之外

```java

public class Test{
    {
      String s = new String("a string"); 
    } // End of scope
}
```

引用s在作用域终点就消失了，然而，s指向的String对象仍继续占据内存空间。在上面的代码中，我们无法在这个作用域之后访问这个对象，因为对它唯一的引用已超出了作用域的范围，而对象的回收，是通过Java的垃圾回收器，它用来监视用new创建的所有对象，并辨别哪些不会再被引用的对象，随后，释放这些对象的内存空间，以便供其他新的对象使用


## 十四. equals()重写

```java
class Value{
    int i;
}

public class EqualMethod2{
    public static void main(String[] args){
        Value v1 = new Value();
        Value v2 = new Value();
        v1.i = 100;
        v2.i = 100;
        System.out.println(v1.equals(v2));
    }
}

// Output
// false
```

当我们用自己创建的类，使用equals()方法来比较，虽然v1和v2两个引用不同，但对象内容是相同的，而且equals()比较的是对象内容的值，但结果确实false。这是由于equals()的默认行为是比较引用。所以除非在自己的新类中覆盖equals()方法，否则比较的还是引用

## 十五. 控制执行流程

就像有知觉的生物一样，程序必须在执行过程中控制它的世界，并做出选择。在Java中，要使用执行控制语句来做出选择。

在Java中，控制语句涉及的关键字包括if-else、while、do-while、for、return、break以及选择语句switch。

### 15.1 true和false

所有条件语句都利用条件表达式的true或false来决定执行路径。要注意的是Java不允许我们将一个数字作为布尔值使用。

### 15.2 if-else

if-else语句是控制程序流程的最基本的形式。其中else是可选的，所以可以按下述两种形式来使用if：

布尔表达式必须产生一个布尔结果，statement指用分号结尾的简单语句 或复合语句—封闭在花括号内的一组简单语句。

```
if(Boolean-expression)// 布尔表达式必须产生一个布尔结果
    statement // 用分号结尾的简单语句

```

或

```
if(Boolean-expression){ 
    statement 
}else{
    statement
}

```
或

```
if(Boolean-expression){ 
    statement 
}else if(Boolean-expression){
    statement
}else{
    statement
}
```

### 15.3 迭代

while、do-while和for用来控制循环，称为迭代语句。语句会重复执行，直到起控制作用的布尔表达式得到false的结果为止。

#### while 与 do-while

while和do-while唯一的区别就是do-while中的语句至少会执行一次，
即便表达式第一次就被计算为false。而在while循环结构种，如果条件第一次就为false，
那么其中的语句根本不会执行。在实际应用中，while比do-while更常用一些


```
// 在循环刚开始时，会计算一次布尔表达式的值；而在语句的下一次迭代开始前会再计算一次
while(Boolean-expression){
    statement
}
```

```
do{
    statement
}while(Boolean-expression)
```


#### for 循环语句

for循环第一次迭代之前要进行初始化。随后，它会进行条件测试，而且在每一次迭代结束时，进行某种形式的“步进”。
 
初始化表达式(initializaion) 布尔表达式(Boolean-expression) 或者步进(step)运算，都可以为空，
全部为空作用相当于while，但分号不能省略。

每次迭代前会测试布尔表达式。若获得的结果是false，就会执行for语句后面的代码行。每次循环结束，会执行一次步进。

```
for(initializaion;Boolean-expression;step){
    statement
}
```

```java
class MyTest{
    public static void main(String[] args){
        for(char c = 0; c < 128;c++){
           if(Charscter.isLower(c)){
                System.out.println("value: " + (int)c + " character: " + c);
            }   
        }
    }
}
```

注意：变量c是在程序用到它的地方被定义的，也就是在for循环的控制表达式里，而不是在main()开始的地方定义的。c的作用于就是for控制的表达式的范围内。

#### 逗号操作符

逗号操作符(注意不是逗号分隔符，逗号用作分隔符时用来分隔函数的不同参数)，Java里唯一用到逗号操作符的地方就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，可以使用一系列由逗号分隔的语句；而且那些语句均会独立执行。

通过使用逗号操作符，可以在for语句内定义多个变量，但是它们必须具有相同的类型

```java
class MyTest{
    public static void main(String[] args){
        for(char c = 0; c < 128;c++){
            for(int i = 1,j = i + 10; i < 5; i ++,j = i * 2){
                System.out.println("i = " + i + " j = " + j);
            }
        }
    }
}
```

#### Foreach语法

> Java SE5引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项
> 
> for(float x : f) 这条语句定义了一个float类型的变量x，继而将每一个的f的元素赋值给x

```java
class MyTest{
    public static void main(String[] args){
        Random rand = new Random(47);
        float f[] = new float[10];
        for(int i = 0; i < 10; i++){
          f[i] = rand.nextFloat();
        }
        for(float x : f){
          Sytem.out.println(x);
        }
    }
}
```

- String使用Foreach

String类有一个方法toCharArray()，它返回一个char数组，因此可以迭代在字符串里面的所有字符：

```java
class MyTest{
    public static void main(String[] args){        
        for(char c : "An African Swallow".toCharArray()){
            System.out.println(c + " ");
        }
    }
}
```


### 15.4 return

return关键词有两方面的用途：一方面指定一个方法返回什么值（假设它没有void返回值，另一方面它会导致当前的方法退出，并返回那个值。)

如果在返回void的方法中没有returan语句，那么在该方法的结尾处会有一个隐式的return，因为在方法中并非总是必须要有一个return语句。

但是，如果一个方法声明它将返回void之外的其他东西，那么必须确保每一条代码路径都将返回一个值

```java
class MyTest{
    static int test(int testval,int target){
        if(testval > target){
            return 1;
        }else if(testval < target){
            return -1;
        }else{
            return 0;
        }        
    }
    public static void main(String[] args){  
        System.out.println(test(10,5));
        System.out.println(test(5,10)); 
        System.out.println(test(5,5));      
    }
}
```


### 15.5 break和continue

在任何迭代语句的主题部分，都可用break和continue控制循环的流程。其中breank用于强行退出循环，不执行循环中剩余的部分。而continue则停止执行当前的迭代，然后退回循环循环起始处，开始下一次迭代

```java
public class MyTest01 {
    public static void main(String[] args){
        for(int i = 0;i < 100;i++){
            if(i == 74){
                break;
            }
            if(i % 9 != 0){
                continue;
            }
            System.out.print(i + " ");
        }

        System.out.println();
        int i = 0;
        while (true){
            i ++;
            int j = i * 27;
            if(j == 1269){
                break;
            }
            if(i % 10 != 0){
                continue;
            }
            System.out.print(i + " ");
        }
    }
}
```

例子中还可以看到“无穷循环”的情况。然而，循环内容有一个break语句，可中止循环。除此之外，continue语句执行序列回到循环的开头，而没有去完成continue语句之后的所有内容。

无穷循环的第二种形式是for(;;)。编译器将while(true)与for(;;)看作是同一回事。所以具体选用哪个取决于自己的编程习惯

### 15.5 switch

switch 有时也被划归为一种选择语句。根据整数表达式的值，switch语句可以从一系列代码中选出一段去执行。

```
switch(integral-selector){
    case integral-value1 : statement;break;
    case integral-value2 : statement;break;
    case integral-value3 : statement;break;
    case integral-value4 : statement;break;
    case integral-value5 : statement;break;
    default: statement;
}
```

其中，integral-selector是一个能够产生整数值的表达式，switch能将这个表达式的结果与每个integral-value相比较。若发现一致，就执行对应的语句（单一语句或多条语句，其中并不需要括号）。若没有发现一致的，就执行default(默认)语句。

在上面的定义中，大家会注意到每个case均以一个break结尾，这样可使执行流程跳转至switch主体的末尾。这是构建switch语句的一种传统方式，但break是可选的。若省略break，会继续执行后面的case语句，直到遇到一个break为止。注意最后的default语句没有break，因为执行流程已到了break的跳转目的地。

switch要求使用一个integral-selector，并且必须是int或char那样的整数值。例如，若将一个字符串或者浮点数作为选择因为使用，那么它们在switch语句里是不会工作的。对于非整数类型，则必须使用一系列if语句。

```java
public class MyTest01 {
    public static void main(String[] args){
        // switch练习
        Random rand = new Random(47);
        for(int i = 0; i < 10; i++){
            int c = rand.nextInt(26) + 'a';
            System.out.print((char)c + ", " + c + ": ");
            switch (c){
                case 'a':
                case 'e':
                case 'i':
                case 'o':
                case 'u': System.out.println("vowel");break;
                case 'y':
                case 'w': System.out.println("Sometimes a vowel");break;
                default: System.out.println("consonant");
            }
        }
    }
}
// Output:
// y, 121: Sometimes a vowel
// n, 110: consonant
// z, 122: consonant
// b, 98: consonant
// r, 114: consonant
// n, 110: consonant
// y, 121: Sometimes a vowel
// g, 103: consonant
// c, 99: consonant
// f, 102: consonant
```

## 十六. 用构造器确保初始化

在Java中，通过构造器，可以确保每个对象都会得到初始化。创建对象时，如果类具有构造器，Java就自动调用相应的构造器，从而保证了初始化的进行。
 
构造器的命名：构造器采用与类相同的名称<这里要注意的是，构造器的名称必须与类名完全相同，所以每个方法首字母小写的规则并不适用于构造器


```java
class Rock{
    // 不接受任何参数的构造器叫做"默认构造器"
    Rock(){
        System.out.println("Rock ");
    }
    public static void main(String[] args) {
        for(int i = 0;i < 3; i++){
            new Rock();
        }
    }
}
```

上面例子中初始化的过程，现在创建对象时：new Rock();
1) 将会为对象分配存储空间，并调用相应的构造器
2) 这就确保了在操作对象之前，它已经被正确的初始化了

### 16.1 默认构造器

默认构造器（又名无参构造器）是没有形式参数的
 
无参构造器的作用是创建一个默认对象。如果你的写的类中没有构造器，则编译器会自动帮你

创建一个默认构造器

```java
class Test03{}
class Test04{
    public static void main(String[] args) {
        Test03 test03 = new Test03();
    }
}
```

new test03() 创建了一个新对象，并调用默认构造器，即使没有明确定义

但如果已经定义了一个构造器（无论是否有参数），编译器都不会帮你自动创建默认构造器

```java
class Test03{    
    Test03(int i){}
    Test03(double d){}
}
class Test04{
    public static void main(String[] args) {
        // Test03 test01 = new Test03(); // 编译器会报错
        Test03 test02 = new Test03(1);
        Test03 test03 = new Test03(1.0);
    }
}
```


### 16.2 有参构造器

构造器也能带有形式参数，以便指定如何创建对象

```java
class MyTest02{
    static int test(int testval,int target){
        if(testval > target) {
            return 1;
        }
        return 0;
    }
}
class Rock{
    Rock(int i){
        System.out.println("Rock " + i + " ");
    }
    public static void main(String[] args) {
        for(int i = 0;i < 3; i++){
            new Rock(i);
        }
    }
}
```

构造器是一种特殊类型的方法，因为他没有返回值，这与返回值为空（void）明显不同。对于空返回值，尽管方法本身不会自动返回什么，但仍可选择让它返回别的东西。

构造器则不会返回任何东西。
 
但new表达式确实了返回了新建对象的引用，但构造器本身并没有任何返回值

## 十七. 方法重载

在Java里，构造器的强制重载方法名的另一个原因。既然构造器的名字已经由类名所决定，就只能有一个构造器名，如果想用多种方式创建一个对象怎么办呢？这就需要两个构造器：一个默认构造器，另一个带有参数的构造器。由于都是构造器，所以它们必须有相同的名字，即类名。为了让方法名相同而形式参数不同的构造器同时存在，必须用到方法重载。同时，尽量方法重载是构造器所必须的，但也可应用于其他方法，且用法同样方便。

```java
class Tree{
    int height;
    Tree(){
        System.out.println("Planting a seeding");
        height = 0;
    }

    Tree(int initialHeight){
        height = initialHeight;
        System.out.println("Creating new Tree that is " + height + " feel tall");
    }

    void info(){
        System.out.println("Tree is " + height+ " feet tall");
    }

    void info(String s){
        System.out.println(s + ": Tree is " + height + " feet tall");
    }

    public static void main(String[] args) {
        for(int i = 0; i < 3; i++){
            Tree t = new Tree(i);
            t.info();
            t.info("overloaded method");
        }
        new Tree();
    }
}
// Output
// Creating new Tree that is 0 feel tall
// Tree is 0 feet tall
// overloaded method: Tree is 0 feet tall
// Creating new Tree that is 1 feel tall
// Tree is 1 feet tall
// overloaded method: Tree is 1 feet tall
// Creating new Tree that is 2 feel tall
// Tree is 2 feet tall
// overloaded method: Tree is 2 feet tall
// Planting a seeding
```

### 17.1 如何区分重载方法

要是几个方法有相同的方法名，Java如何才能知道你指的是哪一个呢？

其实规则很简单：每个重载的方法都必须有一个独一无二的参数类型列表，对于名字相同的方法，除了参数类型的差异以外，甚至参数顺序的不同也足以区分两个方法（不过，一般情况下别这么做，因为这会使代码难以维护）

```java
// 区分重载方法
class OverLoadingOrder{
    static void f(String s,int i){
        System.out.println("String: " + s + ", int: " + i);
    }
    static void f(int i, String s){
        System.out.println("int: " + i + ", String: " + s);
    }
    public static void main(String[] args) {
        f("String first",11);
        f(99,"Int first");
    }
}
```

### 17.2 基本类型的重载

在下面的例子中我们可以看到：数值5会被当作int值处理，所以如果有某个重载方法接收int类型参数，它就会被调用

由此可以说明：如果传入的数据类型（实际的参数类型）小于声明中形式参数类型，实际数据类型就会被提升

但要注意的是，char型不同，如果无法找到接收char参数的方法，就会把cahr类型直接提升到int型

```java
/**
* 在PrimitiveOverloading中，分别创建了f1、f2、f3、f4、f5、f6、f7  
* 和testConstVal、testChar、testByte、testShort、testInt、testLong、testFloat、testDouble 用来测试传入不同基本类型给重载方法如何处理
* 
* 
* 每个方法都有自己的重载方法。
* 
*/ 
class PrimitiveOverloading{

    void f1(char x){
        System.out.print("f1(char)");
    }
    void f1(byte x){
        System.out.print("f1(byte)");
    }
    void f1(short x){
        System.out.print("f1(short)");
    }
    void f1(int x){
        System.out.print("f1(int)");
    }
    void f1(long x){
        System.out.print("f1(long)");
    }
    void f1(float x){
        System.out.print("f1(float)");
    }
    void f1(double x){
        System.out.print("f1(double)");
    }

    void f2(byte x){
        System.out.print("f2(byte)");
    }
    void f2(short x){
        System.out.print("f2(short)");
    }
    void f2(int x){
        System.out.print("f2(int)");
    }
    void f2(long x){
        System.out.print("f2(long)");
    }
    void f2(float x){
        System.out.print("f2(float)");
    }
    void f2(double x){
        System.out.print("f2(double)");
    }


    void f3(short x){
        System.out.print("f3(short)");
    }
    void f3(int x){
        System.out.print("f3(int)");
    }
    void f3(long x){
        System.out.print("f3(long)");
    }
    void f3(float x){
        System.out.print("f3(float)");
    }
    void f3(double x){
        System.out.print("f3(double)");
    }

    void f4(int x){
        System.out.print("f4(int)");
    }
    void f4(long x){
        System.out.print("f4(long)");
    }
    void f4(float x){
        System.out.print("f4(float)");
    }
    void f4(double x){
        System.out.print("f4(double)");
    }

    void f5(long x){
        System.out.print("f5(long)");
    }
    void f5(float x){
        System.out.print("f5(float)");
    }
    void f5(double x){
        System.out.print("f5(double)");
    }

    void f6(float x){
        System.out.print("f6(float)");
    }
    void f6(double x){
        System.out.print("f6(double)");
    }

    void f7(double x){
        System.out.print("f7(double)");
    }

    void testConstVal(){
        System.out.print("5: ");
        f1(5);f2(5);f3(5);  f4(5);f5(5); f6(5); f7(5);
    }

    void testChar(){
        char x = 'x';
        System.out.print("char:");
        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
    }

    void testByte(){
        byte x = 0;
        System.out.print("byte: ");
        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
    }

    void testShort(){
        short x = 0;
        System.out.print("short : ");
        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
    }

    void testInt(){
        int x = 0;
        System.out.print("int : ");
        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
    }

    void testLong(){
        long x = 0;
        System.out.print("long: ");
        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
    }

    void testFloat(){
        float x = 0;
        System.out.print("float: ");
        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
    }

    void testDouble(){
        double x = 0;
        System.out.print("double: ");
        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
    }

    public static void main(String[] args) {
        PrimitiveOverloading p = new PrimitiveOverloading();
        p.testConstVal();
        System.out.println();
        p.testChar();
        System.out.println();
        p.testByte();
        System.out.println();
        p.testShort();
        System.out.println();
        p.testInt();
        System.out.println();
        p.testLong();
        System.out.println();
        p.testFloat();
        System.out.println();
        p.testDouble();
    }
}
// Output
// 5: f1(int)f2(int)f3(int)f4(int)f5(long)f6(float)f7(double)
// char:f1(char)f2(int)f3(int)f4(int)f5(long)f6(float)f7(double)
// byte: f1(byte)f2(byte)f3(short)f4(int)f5(long)f6(float)f7(double)
// short : f1(short)f2(short)f3(short)f4(int)f5(long)f6(float)f7(double)
// int : f1(int)f2(int)f3(int)f4(int)f5(long)f6(float)f7(double)
// long: f1(long)f2(long)f3(long)f4(long)f5(long)f6(float)f7(double)
// float: f1(float)f2(float)f3(float)f4(float)f5(float)f6(float)f7(double)
// double: f1(double)f2(double)f3(double)f4(double)f5(double)f6(double)f7(double)
```

但如果传入的实际参数大于重载方法声明的形式参数，方法接受较小的基本类型作为参数，如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这么做，编译器就会报错

```java
// 基本类型的重载，窄化处理
class Demotion{

    void f1(char x){
        System.out.print("f1(char)");
    }
    void f1(byte x){
        System.out.print("f1(byte)");
    }
    void f1(short x){
        System.out.print("f1(short)");
    }
    void f1(int x){
        System.out.print("f1(int)");
    }
    void f1(long x){
        System.out.print("f1(long)");
    }
    void f1(float x){
        System.out.print("f1(float)");
    }
    void f1(double x){
        System.out.print("f1(double)");
    }

    void f2(byte x){
        System.out.print("f2(byte)");
    }
    void f2(short x){
        System.out.print("f2(short)");
    }
    void f2(int x){
        System.out.print("f2(int)");
    }
    void f2(long x){
        System.out.print("f2(long)");
    }
    void f2(float x){
        System.out.print("f2(float)");
    }
    void f2(double x){
        System.out.print("f2(double)");
    }

    void f3(short x){
        System.out.print("f3(short)");
    }
    void f3(int x){
        System.out.print("f3(int)");
    }
    void f3(long x){
        System.out.print("f3(long)");
    }
    void f3(float x){
        System.out.print("f3(float)");
    }
    void f3(double x){
        System.out.print("f3(double)");
    }

    void f4(int x){
        System.out.print("f4(int)");
    }
    void f4(long x){
        System.out.print("f4(long)");
    }
    void f4(float x){
        System.out.print("f4(float)");
    }
    void f4(double x){
        System.out.print("f4(double)");
    }

    void f5(long x){
        System.out.print("f5(long)");
    }
    void f5(float x){
        System.out.print("f5(float)");
    }
    void f5(double x){
        System.out.print("f5(double)");
    }

    void f6(float x){
        System.out.print("f6(float)");
    }
    void f6(double x){
        System.out.print("f6(double)");
    }

    void f7(double x){
        System.out.print("f7(double)");
    }


    void testDouble(){
        double x = 0;
        System.out.print("double argument: ");
        f1(x);f2((float)x);f3((long)x);f4((int)x);f5((short)x);f6((byte)x);f7((char)x);
    }

    public static void main(String[] args) {
        Demotion p = new Demotion();
        p.testDouble();
    }
}
// Output
// double argument: f1(double)f2(float)f3(long)f4(int)f5(long)f6(float)f7(double)
```

### 17.3 以返回值区分重载方法

如果两个方法拥有相同的类名和参数列表，如果考虑用方法的返回值来区分呢？比如现有有两个方法void f(){}和int f(){return1} 只要编译器可以根据语境明确判断出语义，比如在int x = f()中，那么的确可以据此区分重载方法。不过，有时你并不关心刚发的返回值，你想要的是方法调用的其他效果(这常被称为“为了副作用而调用”)，这时你可能会调用方法而忽略其返回值。如果像这样调用方法f();，此时Java如何才能判断该调用哪一个f()呢？别人该如何理解这种代码呢？因此，根据方法的返回值来区分重载方法是行不通的

## 十八. this关键字

> 同一个类型的两个对象，分别是a和b，如何才能让这两个类都能调用peel()方法呢？

```java
class Banana{  
    void peel(int i){}
}
class Test01{
    public static void main(String[] args) {
        Banana a = new Banana();
        Banana b = new Banana();
        banana01.peel(1);
        banana02.peel(2);
    }
}
```

编译器会把"所操作对象的引用"作为第一个参数传递给peel()。所以上述两个方法的调用就变成了会这样：

```
Banana.peel(a,1);
Banana.peel(b,2);
```

但这是内部的表现形式，编写代码时并不能这么写。如果想在方法内部获得当前对象的引用。可以通过this关键字，
this 关键字只能只能在方法内部使用，表示对"调用方法的那个对象"的引用。但要注意的是：如果在方法内部调用
同一个类的另一个方法，就不必使用this，直接调用即可。当前方法中的this引用会自动应用于同一个类中的其他方法

```java
class Test{
    void pick(){}
    void pit(){pick();}
}
```

**可以使用this，在return语句里返回当前对象的引用**

```java
class Test{
    int i = 0;
    Leaf increment(){
        i++;
        return this;
    }
    void print(){
        System.out.println("i = " + i);
    }
    public static void main(String[] args){
        Leaf x = new Leaf();
        x.increment().increment().increment().print(); // 由于increment()通过this关键字返回了对当前对象的引用，所以很容易在一条语句里对同一个对象执行多次操作
    }
}
// Output
// i = 3
```

**this关键字对于将当前对象传递给其他方法也很有用**

```java
class Person {
     void eat(Apple apple) {
        Apple peeled = apple.getPeeled();
        System.out.println("Yummy");
    }
}
class Peeler {
    static Apple peel(Apple apple) {
        return apple;
    }
}
class Apple {
    Apple getPeeled() {
        return Peeler.peel(this);
    }
    public static void main(String[] args) {
        new Person().eat(new Apple());
    }
}
```

**通过this在构造器中调用构造器**

同一个类可能有多个构造器，可以通过this在构造器中调用构造器，如果在构造器中，为this添加了参数列表。
那么产生对符合参数列表的某个构造器的明确调用。

而且在构造器中只能用this调用一个构造器，并且必须将this调用置于最初始处，否则编译器会报错

```java
class Flower{

    int petalCount = 0;
    String s = "initial value";

    Flower(int petals){
        petalCount = petals;
        System.out.println("Constructor w/ int arg only,petalCount = " + petalCount);
    }

    Flower(String ss){
        System.out.println("Constructor w/ String arg only,petalCount = " + ss);
        s = ss;
    }

    Flower(String s,int petals){
        this(petals);
        //this(s); // 不用调用两个，否则编译器报错
        this.s = s; // 当前对象的s字段
        System.out.println("String & intargs");
    }

    Flower(){
        this("hi" ,47);
        System.out.println("default constructor(no args)");
    }

    void PrintPetalCount(){
        //this(11); // 不能在非构造器使用this
        System.out.println("petalCount = " + petalCount + "s = " + s);
    }

    public static void main(String[] args) {
        Flower x = new Flower();
        x.PrintPetalCount();
    }
}

// Output
// Constructor w/ int arg only,petalCount = 47
// String & intargs
// default constructor(no args)
// petalCount = 47s = hi
```
## 十九. 成员初始化

Java 尽力保证：所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，必须在使用时为变量赋一个默认值，否则编译器会报错

对于类的数据成员（即字段）是基本类型，如果定义是没有初值，编译器也会给一个初始值，如果是在类里定义一个对象引用时，如果不将其初始化，此引用就会获得一个特殊值null

```java
class InitialValues{
    // 只定义字段不赋值
    boolean t;
    char c;
    byte b;
    short s;
    int i;
    long l;
    float f;
    double d;
    InitialValues reference;
    void printInitialValues(){
        System.out.println("Data type Initial value");
        System.out.println("boolean " + t); // boolean 初始值false
        System.out.println("char " + c); // char 初值为0，所以为空
        System.out.println("byte " + b); // byte 初值为0
        System.out.println("short " + s); // short 初值为0
        System.out.println("int " + i); // int 初值为0
        System.out.println("long " + l); // long 初值为0
        System.out.println("double " + d); // double 初值为0.0
        System.out.println("InitialValues " + reference); // 引用类型reference 初值为null
    }

    public static void main(String[] args) {
        InitialValues initialValues = new InitialValues();
        initialValues.printInitialValues();
        /**
         * 可以使用这种写法
         * new InitialValues.printInitialValues();
         */
    }
}
```

**指定初始化 就是在定义类成员变量的地方为其赋值**

```java
class Depth{}

class InitialValues{
    // 定义字段并赋值
    boolean t = true;
    char c = 'x';
    byte b = 47;
    short s = 0xff;
    int i = 999;
    long l = 1;
    float f = 3.14f;
    double d = 3.14159;
    InitialValues reference;
    Depth dep = new Depth();  // 为引用类型赋值，如果没有指定初始值就尝试使用，会出现运行时错误
}
```

**通过调用某个方法来提供初值 ，并且这个方法也可以带有参数，但这些参数必须是已经被初始化了的**

```java
class MethodInit{
    int i = f(); // 通过调用某个方法来提供初值
    int j = g(i); // 方法可以带已经初始化了的参数
    int f(){
        return 11;
    }
    int g(int n){
        return n * 10;
    }   
}
```

但是这样写会报错：

```java
class MethodInit{

    // int j = g(i); // 会报错 
    int i = f(); // 通过调用某个方法来提供初值
    int f(){
        return 11;
    }
    int g(int n){
        return n * 10;
    }   
}
```

上述程序的正确性取决于初始化的顺序，而与其编译方式无关。所以，编译器会对这种“向前引用”报错。

## 二十. 构造器初始化

可以用构造器来进行初始化，在运行时刻，可以调用方法或执行某些工作来确定初值，但要牢记：无法组织自动初始化的进行，它将在构造器之前被调用之前发生。

```java
// 构造器初始化   
class Counter{
    int i;
    Counter(){
        i = 7;
    }
}
```

在上面的代码中：i首先会被置为0，然后变成7；对于所有基本类型和对象引用，包括在定义时已经指定初值的变量，这种情况都是成立的。

因此，编译器不会强制你一定要在构造器的某个地方或在使用之前对元素进行初始化，因为初始化早已得到了保证

- 初始化的顺序

```java
// 初始化顺序
class Window {
    Window(int marker) {
        System.out.println("Window" + marker);
    }
}
class House {
    Window w1 = new Window(1);
    House() {
        System.out.println("House()");
        w3 = new Window(33);
    }
    Window w2 = new Window(2);
    void f() {
        System.out.println("f()");
    }
    Window w3 = new Window(3);

    public static void main(String[] args) {
        House h = new House();
        h.f();
    }
}
// Output
// Window1
// Window2
// Window3
// House()
// Window33
// f()
```

在House类中，几个Window对象的定义穿插在方法各处，但运行结果表示所有的变量都在调用构造器和其他方法之间得到初始化

## 二十一. 静态数据的初始化

无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量。因此它只能作用于域。
 
如果一个域是静态的基本类型域，且没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化值就是null

如果在定义出初始化，采取的方法域非静态数据没什么不同：

```java
class Bowl{
    Bowl(int marker){
        System.out.println("Bowl " + marker);
    }
    void f1(int marker){
        System.out.println("f1 " + marker);
    }
}
class Table{
    static Bowl bowl1 = new Bowl(1);
    Table(){
        System.out.println("Table()");
        bowl2.f1(1);
    }
    void f2(int marker){
        System.out.println("f2 " + marker);
    }
    static Bowl bowl2 = new Bowl(2);
}
class Cupboard{
    Bowl bowl3 = new Bowl(3);
    static Bowl bowl4 = new Bowl(4);
    Cupboard(){
        System.out.println("Cupboard()");
        bowl4.f1(2);
    }
    void f3(int marker){
        System.out.println("f3 " + marker);
    }
    static Bowl bowl5 = new Bowl(5);
}
class StaticInitialization{
    public static void main(String[] args) {
        System.out.println("Creating new Cupboard() in main");
        new Cupboard();
        System.out.println("Creating new Cupboard() in main");
        new Cupboard();
        table.f2(1);
        cupboard.f3(1);
    }
    static Table table = new Table();
    static Cupboard cupboard = new Cupboard();
}
```

由上面的代码可以知道，静态初始化只有在必要时刻才会进行。如果不创建Table对象，也不引用Table.b1或Table.b2，
那么静态的Bowl b1和b2永远都不会被创建。只有在第一个Table对象被创建（或第一次访问静态数据）的时候，它们才会被初始化。并且，此后静态对象不会再次被初始化

初始化的顺序是先静态对象（如果它们尚未因对象创建而被初始化），而后“非静态”对象，从输出结果中可以观察到这一点。

## 二十二. 对象的创建过程

假如现有有个名为Dog的类：

1）即使没有显示地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件

2）然后载入Dog.class，有关静态初始化的所有动作都会执行，因此，静态初始化只在Class对象首次加载的时候进行一次

3）当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间

4）这块存储空间会被清零，这将自动地将Dog对象中的所有基本类型都设置为默认值（对数字来说就是0，对布尔型和字符型也相同），而引用则被设置为null

5）执行所有出现于字段定义处的初始化动作

6）执行构造器

## 二十三. 静态子句
   
Java允许将多个静态初始化组织成一个特殊“静态子句”（有时也叫做“静态块”）
 
与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即使从未创建那个类的对象）

```java
public class Spoon{
    static int i;
    static {
        i = 47;
    }
}
```

## 二十四. 非静态实例初始化

Java中也有被称为初始化的类似语法，用来初始化每一个对象的非静态变量。
  
```java
class Mug{
    Mug(int m){
        System.out.println("Mug " + m);
    }
    void f(int m){
        System.out.println("f " + m);
    }
}
class Mugs{
    Mug mug1;
    Mug mug2;
    {
        mug1 = new Mug(1);
        mug2 = new Mug(2);
        System.out.println("Mug1 & Mug2 initialized");
    }
    Mugs(){
        System.out.println("Mugs");
    }
    Mugs(int i){
        System.out.println("Mugs(int)");
    }
    public static void main(String[] args) {
        System.out.println("Inside main()");
        new Mugs();
        System.out.println("new Mugs() completed");
        new Mugs(1);
        System.out.println("new Mugs(1) completed");
    }
}
// Output
// Inside main()
// Mug 1
// Mug 2
// Mug1 & Mug2 initialized
// Mugs
// new Mugs() completed
// Mug 1
// Mug 2
// Mug1 & Mug2 initialized
// Mugs(int)
// new Mugs(1) completed
```
上面的代码看起来它与静态初始化子句一摸一样，只是少了static关键字。这种语法对于支持“匿名内部类”的初始化是必须的，但是它也使得你可以保证无论调用了哪个显式构造器，某些操作都会发生。从输出可以看到实例化子句是在两个构造器之前执行的

## 二十五. 数组初始化

数组只是相同类型的、同一标识符名称封装到一起的一个对象序列或基本类型数据序列。
 
数组是通过方括号下标操作符[]来定义和使用的。 要定义一个数组，只需在类型名后加上一对空方括号即可int[] a1，方括号也可以置于标识符后面int a1[]

编译器不允许指定数组的大小。现在拥有的只是对数据的引用(已经为该引用分配了足够的存储空间)，而且也没给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式。

### 25.1 数组的三种初始化方式

```
// 第一种，必须在创建数组的地方出现，由一对花括号括起来的值组成的
// 这种情况下，存储空间的分配(等价于使用new)将由编译器负责
// 初始化列表的最后一个逗号是可选的
int[] a1 = {1,2,3,4,5};
```

```
// 第二种，使用new并定义数组的长度
// 数组中元素的基本类型值会自动初始化成空值(对于数组和字符，就是0，对于布尔型，是false)
// 对于这种情况，初始化动作可以出现在代码的任何地方
int[] a1 = new int[20];
```

```
// 第三种
int[] a1 = new int[]{1,2,3,4,5};
```

### 25.2 将一个数组赋值给另一个数组
```
//  这里a2得到了关于a1的一个引用
// 此时修改a2，a1也可以看到
int[] a1 = {1,2,3,4,5};
a2 = a1;
```
### 25.3 获得数组内包含了多少个元素

```
int[] a1 = {1,2,3,4,5};
a1.length; //数组的长度
a1.length - 1; // 数组最大下标数length-1，如果访问超过的下标边界，Java会出现运行时错误
```

### 25.4 创建非基本类型的数组

```
// 创建一个非基本类型的数组，那么就是创建了一个引用数组
Integer[] a = new Integer[10];
a[i] = new Integer(1); // 创建引用数组，即使使用new的方式，也还只是一个引用数组，并且直到通过创建新的Integer对象，并把对象赋值给引用，初始化进程才算结束，如果忘记了创建对象并且试图使用数组中的空引用，就会在运行时产生异常
```

## 二十六. 可变参数列表

由于所有的类都直接或间接继承于Object类，所以可以创建以Object数组为参数方法，以此获取可变参数列表

```java
//  JavaSE5之前
class A{}
public class VarArgs{
  static void printArray(Object[] args){
      for(Object obj : args){
        System.out.println(obj + "");
    }
    System.out.println();
  }

public static void main(String[] args){
      printArray(new Object[]{new Integer(47),new Float(3.14),new Double(11.11)});
      printArray(new Object[]{"one","two","three"});
      printArray(new Object[]{new A(),new A(),new A()});
  }
}
```

JavaSE5增加的新特性，可以使用它们来定义可变参数列表
 
有了可变参数，就不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你去填充数组。此时仍旧是一个数组。但是，这不仅仅只是从元素列表到数组的自动转换，`printArray((Object [])new Integer[]{1,2,3,4,5});`中Integer数组（通过使用自动包装而创建）被转型为一个Object数组，并且传递给printArray()，由于此时它已经是个数组了，所以不会对它执行任何转换。

因此，如果有一组事物，可以把它们当作列表传递，而如果已经有了一个数组，该方法可以把它们当作可变参数列表来接受

- 传递0个参数

```java
public class OptionalTrailingArguments{
    static void f(int required,String... trailing){ // 可变参数列表可以使用任何类型的参数，包括基本类型
        System.out.println("required: " + required + " ");
        for(String s : trailing){
            System.out.println(s + " ");
      }
      System.out.println();
  }

    public static void main(String[] args){
        f(1,"one");
        f(2,"two","three");
        f(1);
    }
}
```

可变参数列表可以使用除Object之外类型的任何类型的参数，包括基本类型。
 
```java
public class VarargType{
    static void f(Character... args){
         System.out.print(args.getClass);
         System.out.println(" length " + args.length);
    }

    static void g(int... args){
         System.out.print(args.getClass); 
         System.out.println(" length " + args.length);
    }
    
    public static void main(String[] args){
        f('a');
        f(); // 如果在列表中没有任何元素，那么转变成的数据的尺寸为0
        g(1);
        g();
        System.out.println("int[]: " + new int[0].getClass());
    }
}
```

```
// 运行结果
class [Ljava.lang.Character; length 1
class [Ljava.lang.Character; length 0
class [I length 1
class [I length 0
int[]: class [I
```

在上面的例子中，getClass()方法属于Object的一部分，它将产生对象的类，并且在打印该类时，可以看到表示
该类类型编码的字符串，前面的"[" 表示这是一个后面紧随类型的数组，而紧随的“I”表示类型为int

这样也验证了使用可变参数列表不依赖自动包装类，而实际上使用的是基本类型

可以在单一的参数列表中将类型混合在一起，而自动包装机制将有选择地将int参数提升为Integer

上面的情况建立在方法接收的参数类型是Interger，如果是int类型，会将Integer转为int

```java

public class AutoboxingVarargs{
    public static void f(Integer... args){
        System.out.println(args.getClass());
        for(Integer s : args){
            System.out.print(s + " ");
        }
        System.out.println();
    }

    public static void g(int... args){
        System.out.println(args.getClass());
        for(Integer s : args){
            System.out.print(s + " ");
        }
        System.out.println();
    }

    public static void main(String[] args){
        f(new Integer(1),new Integer(2));
        f(4,5,6,7,8,9);
        f(10,new Integer(11),12);// 可以在单一的参数列表中将类型混合在一起，而自动包装机制将有选择地将int参数提升为Integer
        System.out.println("============");
        g(10,new Integer(11),12);
    }
}
```

可变参数列表使得重载过程变得复杂了，下面的例子中，编译器都会使用自动包装机制来匹配重载的方法，然后调用最明确匹配的方法，但是在不使用参数调用f()时，编译器就无法直到应该调用哪一个方法了。可以给所有方法增加一个非可变参数，但是建议的是 只在重载方法的一个版本上使用可变参数列表，或者压根不用它

```java
public class OverloadingVarargs{
    static void f(Character... args){
          for(Character c : args){
            System.out.print(c + " ");
          }
          System.out.println();
    }

    static void f(Integer... args){
          for(Integer c : args){
            System.out.print(i + " ");
          }
          System.out.println();
    }

    static void f(Long... args){
          System.out.println("third");
    }

    public static void main(String[] args){
        f(a,b,c);
        f(1);
        f(2,1);
        f(0);
        f(0L);
        // f(); // 无法调用
    }
}
```

## 二十七. 枚举类型

枚举类的语法：由于枚举类型的实例是常量，因此按照命名惯例它们都用大写字母表示（如果一个名字中有多个单词，用下划线将它们隔开）

```java
/**
* 这里创建了一个名为Spiciness的枚举类型，它具有5个具名值
*/
public enum Spiciness{
    NOT,MILD,MEDIUM,HOT,FLAMING
}
```

为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例：

```java
public class SimpleEnumUse{
    public static void main(String[] args){
        Spiciness howHot = Spiciness.MEDIUM;
        System.out.println(howHot);
    }
}
```

在创建enum时，编译器会自动添加一些有用的特性：
 
1) toString() 以便很方便地显示某个enum实例的名字，这正是上面的打印语句如何产生其输出的答案
2) ordinal() 用来表示某个特定enum常量的声明顺序
3) static values() 用来按照enum常量的声明顺序，产生由这些常量值构成的数组

```java
public class EnumOrder{
    public static void main(String[] args){
      for(Spiciness s: Spiciness.values()){
          System.out.println(s + ", ordinal " + s.ordinal());
        }
    }
}
```

由于switch是要在有限的集合中进行选择，enum可以在switch语句中使用

```java
public class Burrito{
    Spiciness degree;
    public Burrito(Spiciness degree){
        this.degree = degree;
    }

    public void describe(){
        System.out.println("this burrito is");
        switch (degree){
            case NOT: System.out.println("not spicy at all");break;
            case MILD:
            case MEDIUM:System.out.println("a little hot");break;
            case HOT:
            case FLAMING:
            default: System.out.println("maybe too hot.");
        }
    }
    public static void main(String[] args){
        Burrito plain = new Burrito(Spiciness.NOT);
        Burrito greenChile = new Burrito(Spiciness.MEDIUM);
        Burrito jalaeno = new Burrito(Spiciness.HOT);
        plain.describe();
        greenChile.describe();
        jalaeno.describe();
    }
}
```

所以，大体上，你可以将enum用作另外一个创建数据类型的方式，然后直接将所得到的类型拿来使用，这正是关键所在。

## 二十八. 抽象类和抽象方法

定义抽象方法，仅有声明而没有方法体，比如abstract void f();，包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的

抽象类不能初始化对象，否则会报编译器错误，如果从一个抽象类继承，并创建子类的对象。子类在创建时必须实现抽象类提供的方法定义。如果不这么做，那么子类也是抽象类，编译器会强制要求用abstract关键字来限定这个类。

可以创建一个没有任何抽象方法的抽象类，因为除了可以只提供声明的抽象方法外，还可以包括普通方法。这种类的作用是阻止产生这个类的任何对象

![](https://upload-images.jianshu.io/upload_images/2765653-7d1dd12d4434c1c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```java
abstract class Instrument{
    private int i;
    public abstract void play(Note n);
    public String what(){
        return "Instrument";
    }
    public abstract void adjust();
}

class Wind extends Instrument{
    @Override
    public void play(Note n) {
        System.out.println("Wind.play()" + n);
    }

    public String what(){
        return "Wind";
    }
    public void adjust(){}
}

class Percussion extends Instrument{
    @Override
    public void play(Note n) {
        System.out.println("Percussion.play()" + n);
    }
    public String what(){
        return "Percussion";
    }
    public void adjust(){}
}

class Stringed extends Instrument{
    @Override
    public void play(Note n) {
        System.out.println("Stringed.play()" + n);
    }
    public String what(){
        return "Stringed";
    }
    public void adjust(){}
}

class Brass extends Wind{
    public void play(Note n) {
        System.out.println("Brass.play()" + n);
    }
    public String what(){
        return "Brass";
    }
}

class Woodwind extends Wind{
    public void play(Note n) {
        System.out.println("Woodwind.play()" + n);
    }
    public String what(){
        return "Woodwind";
    }
}

public class Music4 {

    static void tune(Instrument i){
        i.play(Note.MIDDLE_C);
    }
    static void tuneAll(Instrument[] e){
        for(Instrument i : e){
            tune(i);
        }
    }
    public static void main(String[] args) {
        Instrument[] orchestra = {
                new Wind(),
                new Percussion(),
                new Stringed(),
                new Brass(),
                new Woodwind()
        };
        tuneAll(orchestra);
    }
}
```

## 二十九.接口

interface关键字产生一个完全抽象的类，方法不提供任何具体实现。它允许创建者确定方法名、参数列表、返回类型，但是没有任何方法实现。接口只提供了形式，而未提供任何具体实现

创建接口类，需要interface关键字来替代class关键字。可以在interface关键字前面添加public关键字（但仅限于该接口在其同名的文件中被定义）。如果不添加public关键字，则它只具有包访问权限，这样它就只能在同一个包内可用。在接口中可以显式地将方法声明为public的。

如果接口声明为pulic的，在接口中可以显式地将方法声明为public的，但即使不这么做，它们也是public的。接口也可以包含域，但是这些域隐式是static和final的

一个类实现某个特定接口（或者是一组接口），需要使用implements关键字，一个类实现了某个接口后，这个类就成为一个普通的类，就可以用常规的方式使用继承这个类的方法或扩展这个类的方法

![](https://upload-images.jianshu.io/upload_images/2765653-1883a22d3cc4fd19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```java
interface Instrument{
     int VALUE = 5;
     void play(Note n);
     abstract void adjust();
}

class Wind implements Instrument{
    public void play(Note n) {
        System.out.println(this + ".play()" + n);
    }

    @Override
    public String toString() {
        return "Wind";
    }

    public void adjust(){}
}

class Percussion implements Instrument{
    public void play(Note n) {
        System.out.println(this + ".play()" + n);
    }
    @Override
    public String toString() {
        return "Percussion";
    }

    public void adjust(){}
}

class Stringed implements Instrument{
    public void play(Note n) {
        System.out.println(this + ".play()" + n);
    }
    @Override
    public String toString() {
        return "PercusStringedsion";
    }

    public void adjust(){}
}

class Brass extends Wind{
    @Override
    public String toString() {
        return "Brass";
    }
}

class Woodwind extends Wind{
    @Override
    public String toString() {
        return "Woodwind";
    }
}

public class Music5 {

    static void tune(Instrument i){
        i.play(Note.MIDDLE_C);
    }
    static void tuneAll(Instrument[] e){
        for(Instrument i : e){
            tune(i);
        }
    }
    public static void main(String[] args) {
        Instrument[] orchestra = {
                new Wind(),
                new Percussion(),
                new Stringed(),
                new Brass(),
                new Woodwind()
        };
        tuneAll(orchestra);
    }
}
```

子类继承非接口和多个接口：class A extends B implements Inter1,Inter2,Inter3{}

```java
interface CanFight{
    void fight();
}

interface CanSwim{
    void swim();
}

interface CanFly{
    void fly();
}

class ActionCharacter{
    public void fight(){}
}

class Hero extends ActionCharacter implements CanFight,CanSwim,CanFly{
    public void swim(){}
    public void fly(){}
}
public class Adventure {
    public static void t(CanFight x){
        x.fight();
    }
    
    public static void u(CanSwim x){
        x.swim();
    }
    
    public static void v(CanFly x){
        x.fly();
    }
    
    public static void w(ActionCharacter x){
        x.fight();
    }
    
    public static void main(String[] args){
        Hero h = new Hero();
        t(h);
        u(h);
        v(h);
        w(h);
    }
}
```

Hero组合了具体类ActionCharacter和接口CanFight、CanSwim、CanFly。当通过这种方式将一个具体类和多个接口组合到一起时，具体类必须放在前面，后面跟着的才是接口。Hero中没有显式地提供fight()的定义，由于在父类ActionCharacter存在fight()的定义，

通过继承，可以很容易地在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。这两种情况都可以获得新的接口

```java
interface Monster{
    void manace(); 
}
interface DangerousMonster extends Monster{  // 通过继承在新接口中添加新的方法声明
    void destory(); 
}
interface Lethal{
    void kill(); 
}

class DragonZilla implements DangerousMonster{

    @Override
    public void manace() {}

    @Override
    public void destory() {}
}
interface Vampire extends DangerousMonster,Lethal{ // 通过继承在新接口中组合数个接口
    void drinkBlood();
}

class VeryBadVampire implements Vampire{
    @Override
    public void manace() {
        
    }
    @Override
    public void destory() {

    }
    @Override
    public void kill() {

    }
    @Override
    public void drinkBlood() {

    }
}
public class HarrorShow {
}
```

接口中的任何域都自动是statice和final的，所以接口成为了一种很便捷的用来常见常量组的工具。接口中的域自动是public。在接口中定义的域不能是“空final”

```java
public interface RandVals {
    Random RAND = new Random(47);
    int RANDOM_INT = RAND.nextInt(10);
    long RANDOM_LONG = RAND.nextLong() * 10;
    float RANDOM_FLOAT = RAND.nextFloat() * 10;
    double RANDOM_DOUBLE = RAND.nextDouble() * 10;
}
```

域是static的，它们就可以在类第一次加载时被初始化，这发生在任何域首次被访问。并且这些域并不是接口的一部分，它们的值被存储在该接口的静态存储区域内

```java
public class TestRandVals {
    public static void main(String[] args) {
        System.out.println(RandVals.RANDOM_INT);
        System.out.println(RandVals.RANDOM_LONG);
        System.out.println(RandVals.RANDOM_FLOAT);
        System.out.println(RandVals.RANDOM_DOUBLE);
    }
}
```

