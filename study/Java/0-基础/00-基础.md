- [ ] 接口
                  
- interface 关键字定义类，方法不提供任何具体实现，只有方法名、参数列表、返回类型

- 接口可以声明 public 和包访问权限

     - 接口类型是 public 那么方法即使不显式声明也是 public 的
     - 接口的域也自动是 public 的，除此之外，也是 static 和 final 的，并且必须提供初始值不能是 “空final”
     
- [ ] 抽象类

- 包访问权限或public

- 包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的

- 抽象类可以有抽象方法和普通方法

- [ ] 普通类

- 包访问权限或public

- 如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，从而阻止任何人创建该类的对象。但是有一个例外，就是你在该类的static成员内部可以创建

- 除了已明确指出要从其他类中继承，否则就是在隐式地从Java的标准根类Object进行继承

- 数据成员 
    - public 、 private 、protected 、包访问权限
    - 基本数据类型 Java也会确保它获取一个默认值
    - 引用类型 默认值为 null
    - 每个对象都有用来存储其字段的空间且不能在对象间共享
    - static 关键字修饰变量，意味着这个域不会与包含它的那个类的任何对象实例关联在一起，没有创建类的任何对象可以调用

- final 数据
    - 修饰基本类型：编译器常量必须是基本数据类型，final 修饰且定义的时候必须赋值
    - 既是 static 又是 final 的域只占据一段不能改变的存储空间，用大写表示，并使用下划线分隔各个单词
    - 修饰引用 对于对象引用，final 使引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。但对象自身是可以被修改的。Java并未提供任何使对象恒定不变的途径。这样的限制同样适用数组，它也是对象

- 空白 final 被声明为 final 但又没有给定初值的域。必须在域的定义处或者每个构造器中用表达式对 final 进行赋值

- final 参数，可以读参数，但却无法修改参数。这一特性主要用来向匿名内部类传递数据

- final 方法 类中所有的 private 方法都隐式地指定为是 final 的。由于无法取用 private 方法，所以也就无法覆盖它。可以对 private 方法添加 final 修饰词，但这并不能给该方法增加任何额外的意义

- final 类 当将某个类的整体定义为 final 时，就表明这个类不能被继承
 
- 静态数据的初始化

    - 无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量。因此它只能作用于域。
       
    - 如果一个域是静态的基本类型域，且没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化值就是null
         
- 构造器
    - 如果没有默认的父类构造器，或者想调用一个带参数的父类构造器，就必须用关键字 super 显式地编写调用父类构造器的语句，并且配以适当的参数列表

 
- 方法
    - 方法名和参数列表，合起来被成为 “方法签名” 唯一地标识出某个方法
    - 方法的参数传递的是引用
    - 局部变量，Java不会给默认值，如果在初始化时没有赋值，编译时会报错
    - static 关键字修饰方法，意味着这个方法不会与包含它的那个类的任何对象实例关联在一起，没有创建类的任何对象可以调用
    - 要修改的数据位于当前对象包含的其他对象中，只需要再使用连接句点就可以

```java
public class Test{
    Light light = new Light();
    public static void main(String[] args){
        Test test = new Test();
        test.light.i = 50;   
    }
}
``` 

可变参数列表

- 可变参数列表，如果有一组事物，可以把它们当作列表传递

- 而如果已经有了一个数组，该方法可以把它们当作可变参数列表来接受



- 初始化引用，可以在代码中的下列位置进行

    1）在定义对象的地方，这意味着它们总是能够在构造器被调用之前被初始化
    
    2）在类的构造器中
    
    3）在正要使用这些对象之前，这种方式称为惰性初始化。在生成对象不值得及不必要每次都生成对象的情况下，这种方式可以减少额外的负担
    
    4）使用实例初始化
    
- this 

    - 使用this，在return语句里返回当前对象的引用
    - this关键字对于将当前对象传递给其他方法也很有用
    - 通过this在构造器中调用构造器
        -   而且在构造器中只能用this调用一个构造器，并且必须将this调用置于最初始处，否则编译器会报错


- 静态子句

    - 与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即使从未创建那个类的对象）
    
```java
public class Spoon{
    static int i;
    static {
        i = 47;
    }
}
```  
     
- 对象的创建过程

1）即使没有显示地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件

2）然后载入Dog.class，有关静态初始化的所有动作都会执行，因此，静态初始化只在Class对象首次加载的时候进行一次

3）当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间

4）这块存储空间会被清零，这将自动地将Dog对象中的所有基本类型都设置为默认值（对数字来说就是0，对布尔型和字符型也相同），而引用则被设置为null

5）执行所有出现于字段定义处的初始化动作

6）执行构造器

- 组合的概念
    - 最简单地复用某个类的方式就是直接使用该类的一个对象，另外一种就是将那个类的一个对象置于某个新的类中
    - 将某个类的一个对象置于某个新的类中，这个行为可以称为 "创建一个成员对象"，新类的成员对象通常被声明为priate，这使得可以在不干扰使用的情况下， 修改这些成员，也可以在运行时修改这些成员对象，以实现动态修改程序的行为。

- 字符串初始化两种方式

    1)可以用带引号的文本初始化 `String s = "asdf"` 
    
    2)也可以 `String s = new String("asdf");`
  
- 继承

    - 如果Java的父类拥有某个已被多次重载的方法名称，那么在子类中重新定义该方法名称并不会屏蔽其在父类中的任何版本
    - 向上转型
        - flute 是 Instrument 子类 Wind 的对象，tune() 方法可以接受 Instrument 引用，这里将 Wind 对象传递给 tune()，由于 Java 对类型的检查十分严格，这里 Wind 对象同样也是一种 Instrument 对象，在 tune() 中，程序代码可以对 Instrument 和它所有的子类起作用，这种将 Wind 引用转换为 Instrument 引用的动作，称之为向上转型
        - 因为动态绑定，所以发送给父类的任何消息，子类都可以接收，那么将子类看作是它的父类的过程称为向上转型。
        
    - 后期绑定
        - 在上面的代码中，因为编译器只有1个Instrument引用时，它无法知道究竟调用哪个方法，解决的方法就是后期绑定，后期绑定的含义就是在运行时根据对象的类型进行绑定。后期绑定也叫做动态绑定或运行时绑定。也就是说，编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。
        - 为了执行后期绑定，Java使用了一段特殊的代码替代绝对地址调用。这段代码使用在对象存储的信息来计算方法体的地址，这样，根据这一小段代码的内容，每个对象都可以具有不同的行为表现，当向一个对象发送消息时，该对象就能知道对这条消息应该做些什么
    - 父类的域
       - 当Sub对象转型为Super引用时，任何域访问操作都将由编译器解析，因此不是多态的。在上面的例子中，为Super.field和Sub.field分配了不同的存储空间。这样，Sub实际上包含两个称为field的域：它自己的和它从Super处得到的。然而在引用Sub中的field时所产生默认域并非Super版本的field域。因此，为了得到Super.field，必须显式地指明super.field。在实际开发中，首先要将所有的域设置成private，因此不能直接访问它们，其副作用是只能调用方法来访问。另外，不要对父类中的域和子类中的域赋予相同的名字，因为这种做法容易令人混淆
    
    - 父类静态方法和域
        - 如果某个方法是静态的，它的行为就不具有多态性：静态方法是与类，而并非与单个对象相关联的
   
    - 构造器在多态的层次结构中的调用顺序
        
        - 子类构造过程中调用父类的构造器，而且是按照继承层次逐渐向上链接，以使每个父类的构造器都能得到调用。这样做的原因是：因为构造器的重要任务之一是：检查对象是否被正确地构造，子类只能访问它自己的成员，不能访问父类的成员（父类成员通常是private的）。所以只有父类才能正确的初始化。因此所有的构造器都必须得到调用。在子类的构造器中，如果没有明确指定调用某个父类构造器，子类构造器会自动调用默认构造器，如果不存默认构造器，编译器就会报错（若某个类没有构造器，便器会自动合成出一个默认构造器）
        
        1）先调用父类的构造器，这个步骤会不断的反复递归下去，首先是Meal类，然后是下一层子类Lunch，最后是PortableLunch
        
        2）按声明顺序调用Sandwich成员的初始化方法
        
        3）调用Sandwich构造器
        
    - 对象初始化的实际过程是：
    
        1）在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零
        
        2）如前所述那样调用父类的构造器。此时，调用被覆盖后的draw()方法（在RoundGlyph构造器之前调用），由于步骤1的缘故，此时发现radius的值为0
    
        3）按照声明的顺序调用成员的初始化方法
    
        4）调用子类的构造器主体
        
    - 在子类中的被覆盖的方法可以返回父类方法的返回类型的某种子类类型
    
    - 基本类型的重载
    
        - 如果传入的数据类型（实际的参数类型）小于声明中形式参数类型，实际数据类型就会被提升
        - char型不同，如果无法找到接收char参数的方法，就会把cahr类型直接提升到int型
        - 但如果传入的实际参数大于重载方法声明的形式参数，方法接受较小的基本类型作为参数，如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这么做，编译器就会报错    

- [] 枚举

- 枚举类的语法：由于枚举类型的实例是常量，因此按照命名惯例它们都用大写字母表示（如果一个名字中有多个单词，用下划线将它们隔开）

```java
/**
* 这里创建了一个名为Spiciness的枚举类型，它具有5个具名值
*/
public enum Spiciness{
    NOT,MILD,MEDIUM,HOT,FLAMING
}
```

- 为了使用 enum，需要创建一个该类型的引用，并将其赋值给某个实例：

```java
public class SimpleEnumUse{
    public static void main(String[] args){
        Spiciness howHot = Spiciness.MEDIUM;
        System.out.println(howHot);
    }
}

```

- [ ] 操作符
    
- 当一个 String 后面紧跟着一个+，而这个 + 的后面又紧跟一个非 String 类型的元素时，就会尝试着将这个非 String 类型的元素转换为 String

- 基本数据类型存储了实际的数值，而非指向一个对象的引用，所以在为其复制的时候，是直接将一个地方的内容复制了另一个地方。对基本数据类型使用a=b，那么b的内容就复制给a。若接着又修改了a，此时b根本不会受这种修改的影响

- 但对象赋值的时候，要记住的是我们在对一个对象进行操作时，我们真正操作的是对对象的引用。假使将一个对象赋值给另一个对象，实际是将引用从一个地方复制到另一个地方。这意味着假使对象使用c=d，那么c和d都指向的是原本只有d指向的那个对象，此时我们通过b或c来修改原来的对象，b和c调用那个对象返回的值都是最新的。

- 一元减号用于转变数据的符号而一元加号(+)只是为了与一元减号(-)相对应，但是它位于的作用仅仅是将较小类型的操作数提升为int（byte，short，char转型为int）

- == 和 != 比较基本类型的是值，也适用于所有对象，比较的就是对象的引用

- equals() 用来比较两个对象的实际内容是否相同，但这个方法不适用于“基本类型”，基本类型直接使用 == 和 != 即可

- 逻辑运算符 与(&&)、或(||)、非(!)能根据参数的逻辑关系，生成一个布尔值(true或false)

- 短路一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了

- 三元操作符也称条件操作符，它比较特别的是有三个操作数；但它确实属于操作符的一种，因为它最终也会生成一个值
  
  ```
  // 如果boolean-exp(布尔表达式)的结果为true，就计算value0，而且这个计算结果也就是操作符最终产生的值。
  // 如果boolean-exp的结果为false，就计算value1，同样，它的结果也就成为了操作符最终产生的值
  boolean-exp? value0 : value1 
  ```






- [] 数据结构

数组

- 数组的初始化

    1）int[] a1 = {1,2,3,4,5};
    
    2）int[] a1 = new int[20];
    
    3）int[] a1 = new int[]{1,2,3,4,5};
    
- 数组赋值

    - 将一个数组赋值给另一个数组，这里a2得到了关于a1的一个引用，此时修改a2，a1也可以看到
    
- 数组的常用方法
    - arr.length; //数组的长度
    
- 创建非基本类型的数组 Integer[] a = new Integer[10];

    -  创建引用数组，即使使用new的方式，也还只是一个引用数组，并且直到通过创建新的Integer对象，并把对象赋值给引用，初始化进程才算结束，如果忘记了创建对象并且试图使用数组中的空引用，就会在运行时产生异常
    

```
Integer[] a = new Integer[10];
a[i] = new Integer(1); 
```


- for(float x : f) 这条语句定义了一个float类型的变量x，继而将每一个的f的元素赋值给x

- String类有一个方法toCharArray()，它返回一个char数组，因此可以迭代在字符串里面的所有字符：






    
    








  











  



 

        

