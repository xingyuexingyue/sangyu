## String 是最基本的数据类型吗？

不是

Java 中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean

除了基本类型，剩下的都是引用类型，枚举类型也是一种特殊的引用类型

## float f = 3.4; 是否正确

不正确，float 是单精度，double 是双精度，默认是双精度，直接会赋值给 float 会向下转型，损失精度，所以会报错，如果一定要这样操作，要 (float) 强转。或者 3.4f 表示是 float 标识类型

## short s1 = 1; s1 = s1 + 1; 有错吗 

不正确 数值默认是 int 类型，所以 s1 + 1，要强转才能赋值给 short

short s1 = 1; s1 += 1; 这样正确，因为这个表达式相当于 short = (short)(s1 + 1);

## int 和 Integer 的区别

int 是基本类型，Integer 是的包装类，可以把基本类型当作对象来操作

基本类型：byte short int long float double char boolean
包装类型：Byte Short Integer Long Float Double Character Boolean

```java
public class AutoUnBoxingTest {
    public static void main(String[] args) {
        Integer a = new Integer(3);
        Integer b = 3; // 将 3 自动装箱成 Integer 类型
        int c = 3;
        System.out.println(a == b); // flase 两个引用没有引用同一对
        System.out.println(a == c); // true a 自动拆箱成 int 类型再和 c 比较
        System.out.println(b == c); // true b 自动拆箱成 int 类型再和 c 比较
    }
}
```

下面代码的运行结果：

f1 == f2 true

f3 == f4 false

原因是：

如果整型字面量的值在 -128 到 127 之间，那么不会 new 新的 Integer 对象，而是直接引用常量池中的 Integer 对象

```java
public class Test03 {
    public static void main(String[] args) {
        Integer f1 = 100;
        Integer f2 = 100;
        Integer f3 = 150;
        Integer f4 = 150;
        System.out.println(f1 == f2); // true
        System.out.println(f3 == f4); // false
    }
}
```

## & 和 && 区别

& 有两种用法，按位与和逻辑与，按位与得到一个数字，逻辑与结果只讲真和假
&&  短路与

按位与和短路与的区别是：

如果 && 左边的表达式的值是 false，右边的表达式会被直接短路戴欧，不会进行运算。

比如在验证用户登录时判断用户名不是 null 且不是空字符串，应当写为 username != null && username.equals("")，二者的顺序不能交换，更不能用 & 运算符，因为第一个条件如果不成立，根本不用 username.equals("") 比较，否则会产生 NullPointException

逻辑或 | 和 || 也是相同的逻辑


## Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？

Math.round(11.5) 等于 12
Math.round(-11.5)  等于 -11

原理是在参数上加 0.5 然后进行下取整。

## switch 是否能作用在 byte 上，是否能作用在 long 上，是否能做作用在 String 上

在 Java 5 以前，switch（expr）中，expr 只能是 byte，short，char，int。

从 java 5 开始，Java 中引入了枚举类型，从 java 7 开始引入了 enum 类型

从 java 7 开始，evpr 还可以是字符串（String）

长类型（long）在目前所有的版本中都是不可以的

## 用最优效率的方式计算 2 乘以 8

2 << 3 （左移3为相当于2乘以2的3次方，右移3位相当于2除以2的3次方）

2 * 2的3次方

## 数组有没有 length() 方法，String 有没有 length() 方法？

数组没有，但是有 length 的属性

String 有 length() 方法

## 构造器是否可以被重写

构造器不能被继承，因此不能被重写，但同一个类的构造器可以重载

## 是否可以继承 String 类

不可以，String 类是 final 类，不可以被继承

对 String 类型最好的重用方式是关联关系和依赖关系，而不是继承关系

## String 和 StringBuilder、StringBuffer 的区别

String 只读字符串，不可以被改变；StringBuilder、StringBuffer 表示的字符串对象可以直接进行修改

StringBuilder 是 Java 5 中引入的，它和 StringBuilder 的方法完全相同，区别在于是单线程环境下使用的，因为它的所有方法都没有被 Synchronized 修饰，所以它是线程不安全的

StringBuffer 是线程安全的

## 重载和重写的区别

方法的重载和重写都是实现多态的方式，前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载

重写发生在子类和父类之间，子类重写方法与父类方法有相同的返回类型，比父类被重写方法更好访问，并且可以返回子类型，不能比父类声明更多的异常

重载对返回类型没有特殊的要求

## 是否可以根据返回类型来区分重载 

不可以

原因是：

如果两个方法拥有相同的类名和参数列表，如果考虑用方法的返回值来区分呢？比如现有有两个方法void f(){}和int f(){return1} 只要编译器可以根据语境明确判断出语义，比如在int x = f()中，那么的确可以据此区分重载方法。不过，有时你并不关心刚发的返回值，你想要的是方法调用的其他效果(这常被称为“为了副作用而调用”)，这时你可能会调用方法而忽略其返回值。如果像这样调用方法f();，此时Java如何才能判断该调用哪一个f()呢？别人该如何理解这种代码呢？因此，根据方法的返回值来区分重载方法是行不通的

## 抽象类（abstract class）和接口（interface）异同

相同点：

抽象类和接口都不能实例化

不同点：

1. 抽象类可以定义构造器，可以有抽象方法和具体方法，而接口不能定义构造器而且其中的方法全部都是抽象方法

2. 抽象类中成员可以是private，默认，protected、public的，而接口中的成员都是public的

3. 抽象类中可以定义成员变量，而接口定义的成员实际上都是常量

4. 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法

## 静态变量和实例变量的区别

静态变量是被 static 修饰的变量，也称为类变量，属于类，不属于类的对象

实例变量必须依存于某一个实例，需要先创建对象然后通过对象才能访问到它

## 是否可以从一个静态方法内部发出对非静态方法的调用？

不可以

静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，调用静态方法不需要创建对象

非静态方法内部可以调用静态方法和静态变量

## 接口是否可继承（extends）接口？

接口可以继承接口

## 抽象类是否可以实现接口

可以

## 抽象类是否可以继承具体类

可以

## 一个 .java 源文件中是否可以包含多个类（不是内部类）？有什么限制

可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全一致

## 内部类可以引用外部类的成员吗？

可以，包括私有成员

## Java 中的 final 关键字有哪些用法？

1. 修饰类：表示该类不能被继承

2. 修饰方法：表示方法不能被重写

3. 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）

4. 修饰参数列表的类型：表示只能读取，不能修改

## 字符串转换为基本数据类型？

调用基本数据类型对应的包装类中的方法 parseXXX(String) 或 valueOf(String) 即可返回相应基本类型


字符串转基本类型：

```java
public class MyTest {
    public static void main(String[] args) {
        String i = "123";
        System.out.println(Integer.parseInt(i));

    }
}
```

基本类型转字符串：

```java
public class MyTest {
    public static void main(String[] args) {
        int i = 123;
        System.out.println(String.valueOf(i));
    }
}
```

## 基本类型转换为字符串

1.  + 

2. String.valueOf() 

## 如何实现字符串的反转和替换

```java
public class MyTest{
    public static String reverse(String originStr){
        if(originStr == null || originStr.length() <= 1){
            return originStr;
        }
        return reverse(originStr.substring(1) + originStr.charAt(0));
    }
}
```

## 如何取得年月日、小时分钟秒

创建 java.util.Calendar 实例，调用其 get() 方法传入不同的参数即可获得参数所对应的值。

Java 8 中可以使用 java.time.LocalDateTime 来获取

```java
public class DateTimeTest{
    public static void main(String[] args){
        Calendar cal = Calendar.getInstance();
        System.out.println(cal.get(Calendar.YEAR));
        System.out.println(cal.get(Calendar.MONTH));
        System.out.println(cal.get(Calendar.DATE));
        System.out.println(cal.get(Calendar.HOUR_OF_DAY));
        System.out.println(cal.get(Calendar.MINUTE));
        System.out.println(cal.get(Calendar.SECOND));
        
        // Java 8
        LocalDateTime dt = LocalDateTime.now();
        System.out.println(dt.getYear());  
        System.out.println(dt.getMonthValue());
        System.out.println(dt.getDayOfMonth());
        System.out.println(dt.getHour());
        System.out.println(dt.getMinute());
        System.out.println(dt.getSecond());
    }
}
```

## 如何取得从1970年1月1日0时0分0秒到现在的毫秒数

```
Calendar.getInstance().getTimelnMillis();
System.currentTimeMillis();
Clock.systemDefaultZone().mills(); // Java 8
```

## 如何取得某月的最后一天

```
Calendar time = Calendar.getInstance();
time.getActualMaximum(Calendar.DAY_OF_MONTH);
```

## 如何格式化日期

利用 java.text.DateFormat 的子类（如 SimpleDateFormat 类）中的format(Date) 方法可将日期格式化。

在 java 8 中可以用 java.time.format.DateTimeFormatter 来格式化时间日期

```java
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Date;

class DateFormatTest{
    public static void main(String[] args){
        SimpleDateFormat oldFormatter = new SimpleDateFormat("yyyy/MM/dd");
        Date date1 = new Date();
        System.out.println(oldFormatter.format(date1));
        
        // Java 8
        DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern("yyyy/MM/dd");
        LocalDate date2 = LocalDate.now();
        System.out.println(date2.format(newFormatter));
    }

}
```

## 打印昨天的当前时刻

```java
import java.util.Calendar;

class YesterdayCurrent{
    public static void main(String[] args){
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DATE,-1);
        System.out.println(cal.getTime());
    }
}
```

## Error 和 Exception 的区别？

Error 表示系统级别的错误和程序不必处理的异常

Exception 表示需要捕捉或者需要程序进行处理的异常

## try{} 里有一个 return 语句，那么紧跟在这个 try 后的 finally{} 里的代码会不会被执行，什么时候被执行，在 return 前还是后？

会执行，在方法返回调用前执行

在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立马返回调用者，而是记录返回值待 finally 代码块执行完毕之后再向调用者返回值

如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰

## Java 语言如何进行异常处理，关键字：throws，throw，try，catch，finally 分别如何使用

Java 所有的异常继承自 Throwable，每个异常都是一个对象。

throw 用在方法内抛出一个异常对象

throws 用在方法上后面紧跟的的是异常类

try 中写代码块

catch 要捕获的异常，以及如何处理

finally 不管有无异常 最终都要执行


## List、Set、Map 是否继承自 Collection 接口

List 和 Set 是

Map 不是

## Collection 和 Collections 的区别

Collection 是一个接口，它是 set 和 List 等容器的父接口

Collections 是一个工具类，提供一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序等

## 统计字符串出现的次数

方法一：利用 Pattern 和 Matcher

```java
public class MyUtil {

    public static void main(String[] args) {
        String srcText = "Hello World Hello World Hello World Hello World Hello World";
        String findText = "hello";
        System.out.println(countWordIntStr(srcText,findText));
    }

    public static int countWordIntStr(String srcText, String findText) {
        int count = 0;
        Pattern p = Pattern.compile(findText);
        Matcher m = p.matcher(srcText);
        while (m.find()) {
            count++;
        }
        return count;
    }
}
```

方法二：利用 indexOf()

```java
/**
 * User: pengyapan
 * Date: 2020/5/19
 * Time: 下午5:06
 */
public class MyUtil {

    public static void main(String[] args) {
        String srcText = "Hello World Hello World Hello World Hello World Hello World";
        String findText = "Hello";
        System.out.println(countWordIntStr2(srcText, findText));
    }

    public static int countWordIntStr2(String srcText, String findText) {
        int count = 0;
        int index = 0;
        while ((index = srcText.indexOf(findText,index)) != -1){
            index = index + findText.length();
            count++;
        }
        return count;
    }

}

```


## 统计文件中字符串出现的次数

```java
public class MyUtil {

    public static void main(String[] args) {
        String filename = "/Users/pengyapan/Documents/文档/Ideas/My-day-pratise/src/main/java/com/sangyu/javatest/hello.txt";
        String findText = "Hello";
        System.out.println(countWordIntStr3(filename, findText));

    }
    
    public static int countWordIntStr3(String filename, String findText) {
        int count = 0;
        try {
            FileReader fr = new FileReader(filename);
            BufferedReader br = new BufferedReader(fr);
            String line = "";
            while ((line = br.readLine()) != null) {
                int index = 0;
                while ((index = line.indexOf(findText, index)) != -1) {
                    index = index + findText.length();
                    count++;
                }
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return count;
    }
}
```

## 3 * 0.1 == 0.3 将会返回什么？true 还是 false

false

因为有些浮点数不能完全准确的表示出来


## int 和 Integer 哪个会占用更多的内存

Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间



