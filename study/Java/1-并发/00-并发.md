Java的线程机制都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。  

- Runnable 接口创建任务


```java
public class LiftOff implements Runnable{
    private int countDown = 10;
    private static int taskCount = 0;
    private final int id = taskCount++;
    
    public LiftOff(){}
    
    public liftOff(int countDown){
        this.countDown = countDown;
    }
    public String status(){
        return "#" + id + "(" + (countDown > 0 ? countDown : "LiftOff!") + ")";
    }   
    
    // 实现run方法
    // 设定跳出循环的条件，停止run()方法
    public void run(){ 
        while(countDown >= 0){
            Sytemt.out.println(status());
            countDown--;
            Thread.yield(); 
        }
    }   
}
```

run()方法在main()方法中调用（普通方法的调用，并非线程的启动）。（注意，main()也是一个线程）

```java
public class MainThread{
    public static void main(String[] args){
        LiftOff liftOff = new LiftOff();
        liftOff.run();
    }

}
```

使用 Tread 来驱动 LiftOff 对象，启动任务

Thread 构造器只需要一个 Runnable 对象。调用 Thread 对象的 start() 方法为该线程执行必需的初始化操作，启动新的线程并自动调用 run() 方法。并且启动新的线程后，并不影响 main() 线程的执行。因此启动新的线程后，main() 机组执行。

```java
public class BasicThreads{
    public static void main(String[] args){
        Thread t = new Thread(new LiftOff());
        t.start();
        System.out.println("Waitting for LiftOff");
    }
}
```

启动更多的线程去驱动更多的任务
 
这里要了解下：每个 Thread 都注册了自己，因为确实有一个对它的引用，而且在它的任务退出其 run() 并死亡之前，垃圾回收器无法清除它。因此一个线程会创建一个单独的执行线程，在对 start() 的调用完成之前，它仍旧会继续存在

```java
public class BasicThreads{
    public static void main(String[] args){
        for(int i = 0; i < 5;i++){
            new Thread(new LiftOff()).start();
        }
        System.out.println("Waitting for LiftOff");
    }
}
```

## 4. 使用 Exeutor

JavaSE5 的 java.util.concurrent 包中的执行器（ Exeutor ）将为你管理 Thread 对象。从而简化了并发编程。

Exeutor 为客户端和任务执行之间提供了一个间接层（这里的客户端指的是直接启动线程），与客户端直接执行任务不同，这个中介对象将执行任务

Exeutor 允许你管理异步任务的执行，而无须显示地管理线程的生命周期。Exeutor 在 JavaSE5/6 中是启动任务的优先方法

使用 Exeutor 来替代显示的创建 Thread 对象。ExeutorService（具有服务生命周期的 Exeutor。例如关闭）知道如何创建恰当的上下文来执行 Runnable 对象。

注意，ExeutorService 对象是使用 Exeutor 方法创建的

```java
public class CachedThreadPool{
    public static void main(String[] args){
        ExeutorService exec = Exeutors.newCachedThreadPool();
        for(int i = 0; i < 5; i++){
            exec.execute(new LiftOff());
        }
        exec.shutdown();
    }
}
```

下面我们将newCachedThreadPool替换为newFixedThreadPool，使用有限的线程集来执行所提交的任务

```java
public class CachedThreadPool{
    public static void main(String[] args){
        ExeutorService exec = Exeutors.newFixedThreadPool(5);
        for(int i = 0; i < 5; i++){
            exec.execute(new LiftOff());
        }
        exec.shutdown();
    }
}
```

在上面的例子中，我们通过使用 newFixedThreadPool 一次性预先执行代价高昂的线程分配，因为也就可以限制线程的数量了。这样可以节省时间，因为你不用为每个任务都固定得付出创建线程的开销

要注意：在任何线程池中，现有线程在可能的情况下，都会被自动复用

继续了解下singleThreadExecutor 就像是线程数量为1的newFixedThreadPool。这对于如果希望在另一个线程中连续运行的事物来说，都是很有用的，例如更新本地或远程日志的小任务。

如果向singleThreadExecutor提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前运行结果，所有的任务将使用相同的线程。

因此向singleThreadExecutor会序列化所有提交给它的任务，并会维护它自己（隐藏）的悬挂任务队列

```java
public class SingleThreadExecutor{

    public static void main(String[] args){
        ExeutorService exec = Exeutors.newSingleThreadExecutor();
        for(int i= 0; i < 5;i++){
            exec.execute(new LiftOff());
        }
         exec.shutdown();
    }   
}
```

## 5. 从任务中产生返回值

Runnable 是执行工作的独立任务，但是它不返回任何值，如果你希望任务在完成时能够返回一个值，那么可以实现 Callable 接口而不是 Runnable 接口。

在 JavaSE5 中引入 Callable 是一种具有类型参数的泛型，它的类型参数表示的是从方法 call()（而不是 run(）中返回的值，并且必须使用 ExcutorService.submit() 方法调用它

```java
class TaskWithResult implements Callable<String>{
    private int id;
    public TaskWithResult(int id){
        this.id = id;
    }
    public String call(){
        return "Result od TaskWithResult " + id;
    }
}

public class CallableDemo{
    public static void main(String[] args){
        ExeutorService exec = Exeutors.newCachedThreadPool();
        ArrayList<Future<String>> results = new ArrayList<Future<String>>();
        for(int i = 0; i< 10;i++){
            results.add(exec.submit(new TaskWithResult(i)));
        }
        for(Future<String> fs:results){
            try{
                System.out.println(fs.get);
            }catch(InterruptedException e){
                System.out.println(e);
                return;
            }catch (ExecutionException e){
                System.out.println(e);
            }finally{
                exec.shutdowm();
            }
        }
    }
}
```

在上面的例子中 submit() 方法会产生 Future 对象，它用 Callable 返回结果的特定类型进行了参数化。

可以使用 isDone() 方法来查询 Future 是否已经完成。

当任务完成时，它具有一个结果，你可以调用 get() 方法来获取该结果。

也可以不同 isDone() 进行检查就直接调用 get()。在这种情况下，get() 将阻塞，直到结果准备就绪。所以可以在试图调用 get() 之前，先调用具有超时的 get()或者调用 isDone() 来查看任务是否完成

## 6. 休眠

影响任务行为的一种简单方法是调用 sleep()，这将使任务中止执行给定的时间

```java
public class SleepingTask extends liftOff{
    public void run(){
        try{
            while(countDown >0){
                System.out.println(status());
                TimeUnit.MILLISECONDS.sleep(100);
            }
        }catch (InterruptedException e){
            System.out.println("Interrupted");
        }
    }
    public static void main(String[] args){
    
        ExecutorService exec = Exectors.newCacedThreadPool();
        for(int i = 0;i<5;i++){
            exec.execute(new SleepingTask());
        }
        exec.shutdown();
    }   

}
```

要注意的是，对 sleep() 的调用可以抛出 InterruptedException 的异常，因为异常不能跨线程传播回 main()，所以你必须在本地处理所有在任务内部产生的异常

使用 sleep() 延迟后，每个任务都将要睡眠在执行打印语句之后，这使得线程调度器可以切换到另一个线程，进而驱动另一个任务。


## 7. 优先级

线程的优先级将该线程的重要性传递给了调取器，尽管 CPU 处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先级最高的线程先执行。然后这并不意味着优先级较低的线程将得不到执行（也就是说，优先级不会导致死锁）。优先级较低的线程仅仅是执行的频率较低

在大多数的时间里，所有线程都应该以默认的优先级运行。

可以使用 getPriority() 来去读现有线程的优先级，并且在任何时刻都可以通过 setPriority() 来修改它

```java
public class SimplePriorities implements Runnable{
    private int countDown = 5;
    private volatile double d;
    private int priority;
    public SimplePriorities(int priority){
        this.priority = priority;
    }
    public String toString(){
        return Thread.currentThread() + ": " + countDown;
    }
    public void run(){
        Thread.currentThread().setPriority(priority);
        while(true){
            for (int i = 1;i<10000;i++){
                d += (Math.PI + Math.E);
                if (i % 1000 == 0){
                    Thread.yield();
                }
            }
            System.out.println(this);
            if((--countDown )== 0){
                return;
            }
        }
    }
    public static void main(String[] args){
        ExecutorService exec = Exectors.newCacedThreadPool();
            for(int i = 0;i<5;i++){
                exec.execute(new SimplePriorities(Thread.MIN_PRIORITY));
                exec.execute(new SimplePriorities(Thread.MAX_PRIORITY));
            }
            exec.shutdown();
    }

}
    
```

在上面的例子中，toString() 方法被覆盖，以便使用 Thread.toString() 方法来打印线程的名称，线程的优先级以及线程所属的线程组

通过调用 Thread.currentThread() 来获得对驱动该任务的 Thread 对象的引用。

## 8. 让步

完成了在 run() 方法后，就可以高度线程调度机制：工作完成的差不多了，可以让别的线程使用CPU了。这个过程也可以通过用 yield() 方法来通知(这只是一个通知，没有任何机制保证它将会被采纳)，当调用时，也可以建议具有相同优先级的其他线程可以运行


Thread.yield(); 将CPU从一个线程转移给另一个线程。它的声明表示：线程已经执行完生命周期中最重要的部分了，此刻正式切换给其他任务执行一段时间的大好实际。



```
public class Test06 {
    public static void main(String[] args) {
        MyThread03 t1 = new MyThread03("t1");
        MyThread03 t2 = new MyThread03("t2");
        t1.start();
        t2.start();
    }
}

class MyThread03 extends Thread{
    MyThread03(String s){
        super(s);
    }

    @Override
    public void run() {
        for(int i = 0;i <=100;i++){
            System.out.println(getName() + ": " + i);
            if(i % 10 == 0){
                yield();
            }
        }
    }
}
```

## 9. 后台线程

所有后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程。

反过来说，只要有任何非后台线程还在运行，程序就不会终止。比如，执行 main() 就是一个非后台线程

## 10. 继承 Thread 创建任务

定义个 Thread 的子类并重写其 run 方法如：

```
class MyThread extends Thread{
    public void run(){}
}
```

```
public class TestThread02 {
    public static void main(String[] args) {
        Runner2 r = new Runner2(); // 生成该类的对象
        r.start();
        for(int i=0;i<100;i++){
            System.out.println("Main Thread : " + i);
        }
    }

}

class Runner2 extends Thread{
    @Override
    public void run() { // 结束线程最好的方式 run方法结束 线程就结束了
        for(int i=0;i<100;i++){
            System.out.println("Runner2 : " + i);
        }
    }
}
```

两种方式如何选择，接口比继承更加灵活

## 11. 线程状态转换

![](https://upload-images.jianshu.io/upload_images/2765653-c3d3890148636826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


```isAlive()```判断线程是否或者，即线程是否还未终止
```getPriority()``` 获得线程的优先级数值
```setPriority()``` 设置线程的优先级数值
```Thread.sleep()``` 将当前线程睡眠指定毫秒数
```join()``` 调用某线程的该方法，将当前线程与该线程合并，即等待该线程结束，再恢复当前线程的运行
```yield()``` 让出CPU，当前线程进入就绪队列等待调度
```wait()```当前线程进入对象的wait pool
```notify()``` 唤醒对象的wait pool中的一个等待线程
```notifyAll() ``` 唤醒对象的wait pool中的所有等待线程

## 12. sleep()

持有当前线程使得当前线程休眠（暂时停止执行 millis 毫秒），sleep() 是静态方法，可以使用类名直接调用

```
public class Test04 {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
        try {
            Thread.sleep(10000);
            System.out.println("hhh");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}

class MyThread extends Thread{
    @Override
    public void run() { // 重写方法不能抛出被重写方法不同的异常
        while (true){
            System.out.println("=======" + new Date() + "======");
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                return;
            }
        }
    }
}
```

## 13. join() 合并某个线程

```
public class Test05 {
    public static void main(String[] args) {
        MyThread2 myThread2 = new MyThread2("myThread2");
        myThread2.start();
        try{
            myThread2.join();
            System.out.println("合并myThread2，等待myThread2线程结束，开始执行main()方式");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class MyThread2 extends Thread{
    MyThread2(String s){
        super(s);
    }

    @Override
    public void run() {
        for(int i =1;i<=10;i++){
            System.out.println("I am " + getName());
        }
        try {
            System.out.println("开始等待");
            sleep(10000);
            System.out.println("等待结束，执行main()");

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

## 14. 线程的优先级别

Java 提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。线程调度器按照线程的优先级决定应调度哪个线程来执行

线程的优先级用数字表示，范围从1到10，一个线程的缺省优先级是5

```
Thread.MIN_PRIORITY = 1
Thread.MAX_PRIORITY = 1
Thread.NORM_PRIORITY = 5
```

使用```getPriority()``` 和```setPriority()``` 获得和设置线程的优先级数值

```
public class Test07 {
    public static void main(String[] args) {
        Thread t1 = new Thread(new T1());
        Thread t2 = new Thread(new T2());
        t1.setPriority(Thread.NORM_PRIORITY);
        t1.start();
        t2.start();
    }
}

class T1 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("T1: " + i);
        }
    }
}

class T2 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("-------------T2: " + i);
        }
    }
}
```

```
public class Test08 {
    public static void main(String[] args) {
        Thread t1 = new Runner6();
        t1.start();
        for (int i = 0; i < 50; i++) {
            System.out.println("MainThread : " + i);
        }
    }
}

class Runner6 extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().isAlive());
        for (int i = 0; i < 100; i++) {
            System.out.println("SubThread : " + i);
        }
    }
}
```

## 15. 线程同步

先看一个例子

```
public class Test09 implements Runnable {
    Timer timer = new Timer();
    public static void main(String[] args) {
        Test09 test09 = new Test09();
        Thread t1 = new Thread(test09);
        Thread t2 = new Thread(test09);
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();
    }
    @Override
    public void run() {
        timer.add(Thread.currentThread().getName());
    }
}
class Timer {
    private static int num = 0;
    public void add(String name) {
        num++;
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
        }
        System.out.println(name + ", 你是第" + num + "使用timer的线程");
    }
}
// 执行结果：开启了两个线程，其中一个线程调用run()方法进入add()方法后，num+1 并开始sleep，此时另一个线程也已经调用run()方法进入add()方法后，num+1，第一个进入休眠的现线程结束并，打印num=2，另一个线程也在不久后结束休眠，打印num=2
t2, 你是第2使用timer的线程
t1, 你是第2使用timer的线程
```

```
public class Test09 implements Runnable {
    Timer timer = new Timer();
    public static void main(String[] args) {
        Test09 test09 = new Test09();
        Thread t1 = new Thread(test09);
        Thread t2 = new Thread(test09);
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();
    }
    @Override
    public void run() {
        timer.add(Thread.currentThread().getName());
    }
}
class Timer {
    private static int num = 0;

    public void add(String name) {
        synchronized (this) { // 锁定当前对象，当一个线程对象再执行其他线程不能打断
            num++;
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
            }
            System.out.println(name + ", 你是第" + num + "使用timer的线程");
        }
    }
}
```

在Java语言中，引入了对象互斥锁的概念，保证共享数据操作的完整性。每个对象都对应一个可称为“互斥锁”的标记，这个标记保证在任一时刻，只能有一个线程访问该对象

关键字 syschronized 来与对象的互斥锁联系。当某个对象 syschronized 修饰时，表明该对象在任一时刻只能由一个线程来访问

```
synchronized (this) { // 锁定当前对象，当一个线程对象再执行其他线程不能打断
            num++;
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
            }
            System.out.println(name + ", 你是第" + num + "使用timer的线程");
}

// 还可以放在方法声明中，表示整个方法为同步方法
synchronized public void add(String name){}
```

## 16. 死锁

 ```
public class Test10 implements Runnable{
    public int flag = 1;
    static Object o1 = new Object();
    static Object o2 = new Object();
    
    @Override
    public void run() {
        System.out.println("flag = " + flag);
        if(flag == 1){
            synchronized (o1){
                try{
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o2){
                    System.out.println("1");
                }
            }
        }
        
        if(flag == 0){
            synchronized (o2){
                try{
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1){
                    System.out.println("0");
                }
            }
        }
    }

    public static void main(String[] args) {
        Test10 t1 = new Test10();
        Test10 t2 = new Test10();
        t1.flag = 1;
        t1.flag = 0;
        Thread td1 = new Thread(t1);
        Thread td2 = new Thread(t2);
        td1.start();
        td2.start();
    }
}
```

## 17. 为某个对象加锁

```
package com.sangyu.test.test23;

/**
 * User: pyp
 * Date: 2020/3/26
 * Time: 下午3:45
 */
public class Test03 {
    private int count = 10;
    private Object o = new Object();
    
    public void m(){
        synchronized (o){ // 任何线程在要执行下面的代码时，必须要先拿到o的锁
            count--;
            System.out.println(Thread.currentThread().getName() + " count = " + count);
        }
    }
}
```

先分析对象存储：

![](https://upload-images.jianshu.io/upload_images/2765653-4b74e345150b47ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


分析上面代码加锁的过程：

![](https://upload-images.jianshu.io/upload_images/2765653-fe0b839fea3eb329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上面的这种锁就称为互斥锁。每次只能一个线程去执行。只要有一个线程拿到这把锁其他线程就不能执行了

## 18. this 加锁

```
package com.sangyu.test.test23;

/**
 * User: pyp
 * Date: 2020/3/26
 * Time: 下午4:16
 */
public class Test04 {
    private int count = 10;
    public void m(){
        synchronized (this){ // 任何线程在要执行下面的代码时，必须要先拿到this的锁
            count--;
            System.out.println(Thread.currentThread().getName() + " count = " + count);
        }
    }
}
```

## 19. 执行代码的时候锁定当前对象

```
/**
 * User: pyp
 * Date: 2020/3/26
 * Time: 下午4:26
 */
public class Test04 {
    private int count = 10;
    public void m(){
        synchronized (this){ // 任何线程要执行下面的代码，必须先拿到this的锁
            count--;
            System.out.println(Thread.currentThread().getName() + " count = " + count);
        }
    }
}
```

## 20. 锁定静态方法

```
package com.sangyu.test.test23;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午4:24
 */
public class Test05 {
    private static int count = 10;
    public synchronized  static void m(){ // 这里等同于synchronized(xxx.x.T.class)
        count--;
        System.out.println(Thread.currentThread().getName() + " count = " + count);
    }
    
    public static void mm(){
        synchronized (Test05.class){
            count--;
        }
    }
}
```

## 21. 线程重入的问题

```
package com.sangyu.test.test23;

/**
 * User: pyp
 * Date: 2020/3/26
 * Time: 下午4:28
 */
public class Test06 implements Runnable{

    private int count = 10;
    public void run(){
        count--;
        System.out.println(Thread.currentThread().getName() + "  count = " + count);
    }

    public static void main(String[] args) {
        Test06 test06 = new Test06();
        for (int i = 0;i<5;i++){
            new Thread(test06).start();
        }
    }
}
```

多运行几次，结果中会出现的重复的情况

```
// 上面代码的执行结果，多运行几次就会出现重复的情况，正常应该是5个线程执行5次后，打印出来的是98765
Thread-2  count = 7
Thread-0  count = 8
Thread-1  count = 7
Thread-3  count = 6
Thread-4  count = 5
```

分析产生上面问题的原因：

![](https://upload-images.jianshu.io/upload_images/2765653-1452262cdc525f36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

解决线程重入的问题，给run()方法增加一个锁

由此可以发现：一个syschronized对应的是原子性操作，原子是不可分，一个线程在执行过程是不可能被打断的。

```
package com.sangyu.test.test23;

/**
 * User: pyp
 * Date: 2020/3/26
 * Time: 下午4:50
 */
public class Test07 implements Runnable {
    private int count = 10;
    
    @Override
    public synchronized void run() {
        count--;
        System.out.println(Thread.currentThread().getName() + " count = " + count);
    }

    public static void main(String[] args) {
        Test07 test07 = new Test07();
        for(int i = 0; i < 5;i++){
            new Thread(test07).start();
        }
    }
}
```
## 22. 同步方法和非同步方式是否可以同时调用

```
package com.sangyu.test.test23;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午4:54
 */
public class Test08{
    public synchronized void m1(){
        System.out.println(Thread.currentThread().getName() + " m1 start... ");
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " m1 end");
    }

    public void m2(){
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " m2 ");
    }

    public static void main(String[] args) {
        Test08 test08 = new Test08();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test08.m1();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test08.m2();
            }
        }).start();
    }
}
```

```
# 上面代码的执行结果：m1() 执行中，m2可以执行
# 说明在一个sychronize方法执行过程中，非sychronize方法可以执行，只有sychronize方法在运行的时候需要申请锁，其他非sychronize方法不需要申请锁
Thread-0 m1 start... 
Thread-1 m2 
Thread-0 m1 end
```

## 23. 对业务方法加锁

对业务写方法加锁但对读不加锁，这种情况容易产生脏读的问题

```
package com.sangyu.test.test23;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午6:21
 */
public class Test09 {
    String name;
    double balance;

    public synchronized void set(String name, double balance) { // 对写加锁，对读不加锁
        this.name = name;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.balance = balance;
    }

    public double getBalance(String name) {
        return this.balance;
    }

    public static void main(String[] args) {
        Test09 test09 = new Test09();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test09.set("aa",100);
            }
        }).start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(test09.getBalance("aa"));
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(test09.getBalance("aa"));
    }
}
```

```
# 上面代码的执行结果
0.0
100.0
# 如果把set里sleep去掉，两次结果都是100
# 这说明，如果一个写方法有其他逻辑，如果修改了set后还没有提交时，这个时候其他线程如果去读，会产生脏读的问题，就是结果不一样的情况
```

## 24. 一个同步方法是不是可以调用另一个同步方法

一个同步方法可以调用另一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁，也就是说sychronized获得的锁是可重入的。
```
package com.sangyu.test.test23;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午6:37
 */
public class Test10 {
    synchronized void m1(){
        System.out.println("m1 start");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        m2();
    }

    synchronized void m2(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("m2");
    }

    public static void main(String[] args) {
        Test10 test10 = new Test10();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test10.m1();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test10.m2();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test10.m2();
            }
        }).start();
    }
}
```

## 25. 子类调用父类的同步方法

一个同步方法可以调用另一个同步方法，一个线程已经拥有某个线程的锁，再次申请的时候仍然会得到该对象的锁。也就是说 synchronized 获得的锁是可重入的。在继承的场景中，子类调用父类的同步方法也可以优先获得锁。

```
package com.sangyu.test.test23;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午6:46
 */
public class Test11 {
    synchronized void m(){
        System.out.println("m start");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("m end ");
    }

    public static void main(String[] args) {
        new TestTwo().m();
    }
}

class TestTwo extends Test11{
    synchronized void m(){
        System.out.println("child m start");
        super.m();
        System.out.println("child m end");
    }
}
```

```
# 上面代码的执行结果：
child m start
m start
m end 
child m end
```

## 26. 出现异常时，锁释放

程序在执行过程中，如果出现异常，默认情况锁会释放。

所以在并发处理的过程中，有异常要更加小心，不然可能会发生不一致的情况。

比如，在一个 web app 处理过程中，多个 servlet 线程共同访问同一个资源，这时如果异常处理不合适，在第一个线程中抛出异常，其他线程就会进入同步代码区。有可能会访问到异常产生时的数据。

因此要非常小心的处理同步业务逻辑中的异常。

```
package com.sangyu.test.test23;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午6:55
 */
public class Test1 {
    int count = 0;
    synchronized void m(){
        System.out.println(Thread.currentThread().getName() + " start");
        while (true){
            count++;
            System.out.println(Thread.currentThread().getName() + " count = " + count);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (count == 5){
                int i = 1/0; // 此处抛出异常，所将被释放，要想不被释放，可以在这里进行try-catch，然后让循环继续，增加finally，回滚数据
            }
        }
    }

    public static void main(String[] args) {
        Test1 test1 = new Test1();
//        test1.m();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test1.m();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test1.m();
            }
        }).start();
    }
}
```

![](https://upload-images.jianshu.io/upload_images/2765653-ac3c6c3330d88c53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 27. volatile

volatile 关键字，使一个变量在多个线程间可见。

A B 线程都用到一个变量，java 默认是 A 线程中保留一份 copy，这样如果B线程修改了该变量，则A线程未必知道

使用 volatile 关键字，会让所有线程都会读到变量的修改值

在下面的代码中，running 是存在于堆内存的t对象中
当线程t1开始运行的时候，会把 running 值从内存值从内存中读到 t1 线程的工作区，在运行过程中直接使用这个 copy，并不会每次都去读堆内存，这样，当主线程修改 running 的值之后，t1 线程感知不到，所以不会停止

使用 volatile 关键字之后，将会强制所有线程都去堆内存中读取 running 的值

volatile 并不能保证多个线程共同修改 running 变量时所带来的不一致问题，也就是说 volatile 不能替代 synchronized

```
package com.sangyu.test.test23;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午7:26
 */
public class Test12 {
    volatile boolean running = true; // 对比有无volatile的情况下，整个程序运行结果的区别
    void m(){
        System.out.println("m start");
        while (running){

        }
        System.out.println("m end!");
    }

    public static void main(String[] args) {
        Test12 test12 = new Test12();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test12.m();
            }
        }).start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        test12.running = false;
    }
}
```

JMM 中主内存，每个线程有自己的内存（线程存放自己变量的内存还有CPU的缓冲），如果线程，就会有多个缓冲区，每个线程会把主内存里的东西读取来到自己的缓冲区，CPU 在处理的时候就不去主内存里读这个内存了。这个时候其他线程在修改后，更新到主内存，但是的第一个线程并没有去主内存里取读

加了 volatile 后，增加线程间的可见性，主内存的发生改变的后，会通知其他线程所有缓冲区，你们内存的内容过期了，需要去主内容重新读取更新。

没有 volatile ，在 run 中增加 sleep，上面的问题会没有了

![](https://upload-images.jianshu.io/upload_images/2765653-61466e389741098e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

产生的原因是，在 run 中增加语句后，CPU 改变原来一直执行的状态，此时产生了空闲，有可能去主线程刷新下内容。所以会访问到。

但是为了保证线程间的可见性，需要使用 volatile。需要对两个线程共同访问的变量增加 volatile。 不用 volatile 也可以使用 synchronized 语法，volatile 比 synchronized 效率要高。用 volatile 的是时候就不要加锁

synchronized 即保证了可见性有保证了原子性

## 28. 使用synchronized 和volatile的区别

volatile 并不能保证多个线程共同修改 running 变量时所带来的不一致的问题，也就是说 volatile 不能替代 synchronized

```
package com.sangyu.test.test23;

import java.util.ArrayList;
import java.util.List;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午8:16
 */
public class Test13 {
    volatile int count = 0;
    void m(){
        for(int i = 0;i<10000;i++){
            count++;
        }
    }

    public static void main(String[] args) {
        Test13 test13 = new Test13();
        List<Thread> threads = new ArrayList<>();

        for(int i = 0; i < 10;i++){
            threads.add(new Thread(new Runnable() {
                @Override
                public void run() {
                    test13.m();
                }
            }));
        }

        for (Thread thread:threads){
            thread.start();
        }

        for (Thread thread:threads){
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(test13.count);
    }
}
// 执行结果
// 74659
// 产生这样的结果是，每个线程修改数据后会更新到主内存，主内存更新会通知其他线程重新读取主线程的数据，在这个过程，写回来的数据并不能保证是最新。只是单纯写回来
```

## 29. 使用Synchronized解决上面的问题

对比上一个程序，可以用 synchronized 解决，synchronized 可以保证可见性和原子性，volatile 只能保证可见性

```
package com.sangyu.test.test23;

import java.util.ArrayList;
import java.util.List;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午8:28
 */
public class Test14 {
    int count = 0;

    synchronized void m() {
        for (int i = 0; i < 10000; i++) {
            count++;
        }
    }

    public static void main(String[] args) {
        Test14 test14 = new Test14();
        List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            threads.add(new Thread(new Runnable() {
                @Override
                public void run() {
                    test14.m();
                }
            }));
        }

        for (Thread thread : threads) {
            thread.start();
        }

        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(test14.count);
    }
}
```

## 30. 使用 AtomXXX 类

解决同样的问题的更高效的方法，使用AtomXXX类

AtomXXX 类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的

```
package com.sangyu.test.test23;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午8:31
 */
public class Test15 {

    AtomicInteger count = new AtomicInteger(0);
    void m(){
        for(int i = 0;i<10000;i++){
            // if count.get() < 1000 // 如果用到两个AtomicInteger的方法，不加锁的还是会被其他线程打断，产生这个问题的原因是：在两个方法执行中间会可能会被其他线程打断
            count.incrementAndGet(); // count++不具备原子性，但是incrementAndGet方法具有原子性，在执行结束前其他线程不能打断它
        }
    }

    public static void main(String[] args) {
        Test15 test15 = new Test15();
        List<Thread> threads = new ArrayList<>();

        for(int i = 0; i < 10; i++){
            threads.add(new Thread(new Runnable() {
                @Override
                public void run() {
                    test15.m();
                }
            }));
        }
        for (Thread thread : threads) {
            thread.start();
        }

        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(test15.count);
    }
}
```

## 31. synchronized 优化

同步代码块中的语句越少越好，比较下列代码中的m1和m2

```
package com.sangyu.test.test23;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午8:40
 */
public class Test16 {
    int count = 0;
    synchronized void m1(){
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁
        count++;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    synchronized void m2(){
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁
        // 采用细粒度的锁，可以使线程争用时间变短，从而提高效率
        synchronized (this){
            count++;
        }
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }   
    }
}
```

## 32. 避免将锁定对象改为另一个对象

锁定某对象o，如果o的属性发生改变，不影响锁的使用

但是如果o变成另外一个对象，则锁定的对象发生改变

应该避免将锁定对象变成另外的对象

```
package com.sangyu.test.test23;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午8:44
 */
public class Test17 {
    Object o = new Object();

    void m(){
        synchronized (o){
            while (true){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println(Thread.currentThread().getName());
            }
        }
    }

    public static void main(String[] args) {
        Test17 test17 = new Test17();

        // 启动一个线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                test17.m();
            }
        }).start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 创建第二个线程
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                test17.m();
            }
        });

        test17.o = new Object(); // 锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会
        thread.start();
    }
}
// 根据上面的代码也可以说明，锁的堆内存里的对象，并不是栈里面的引用，因为引用并没有改变。改变的是引用指向的对象
```


![image.png](https://upload-images.jianshu.io/upload_images/2765653-5753b21e5364c89f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 33. 不要以字符串作为锁的对象

在下面的例子中，m1和m2其实锁定的是同一个对象

这种情况还会发生比较诡异的现象，比如你用到了一个类库，在该类库中代码锁定了字符串“hello” ，但是在你的代码中也锁定了“hello”，这时候就有可能发生比较诡异的死锁阻塞，因为你的程序和你用到的类库不经意间使用了同一把锁

```
package com.sangyu.test.test23;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午8:54
 */
public class Test18 {

    String s1 = "Hello"; // s1和s2之所以是同一对象的原因是：字符串常量池
    String s2 = "Hello";

    void m1(){
        synchronized (s1){

        }
    }

    void m2(){
        synchronized (s2){

        }
    }

    public static void main(String[] args) {
        Test18 test18 = new Test18();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test18.m1();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                test18.m2();
            }
        }).start();
    }
}
```

## 34. 曾经的面试题

实现一个容器，提供两个方法：add，size

写两个线程，线程1添加10个元素到容器中，线程2实时监控元素的个数，当个数到5个时，线程2给出提示并结束

```
package com.sangyu.test.test23;

import java.util.ArrayList;
import java.util.List;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午9:01
 */
public class Test19 {

    // 增加volatile ，使t2能够得到通知
    List lists = new ArrayList();

    public void add(Object o) {
        lists.add(o);
    }

    public int size() {
        return lists.size();
    }

    public static void main(String[] args) {
        Test19 test19 = new Test19();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    test19.add(new Object());
                    System.out.println("add " + i);
                }

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true){
                    if(test19.size() == 5){
                        break;
                    }
                }
                System.out.println("t2 结束");
            }
        }).start();
    }
}
// 程序执行后无法停止，通过添加volatile 使数组可见
// 上面的问题会出现两个问题：没有加同步，如果两一个线程又增加了一个，这个时候可能打印出来的就是6
```

## 35. 使用 wait 和 notify

在上面的面试题中，给 lists 添加 volatile 之后，t2能够接到通知，但是，t2线程的死循环浪费了 cpu，如果不用死循环，该怎么做呢？

这里使用wait 和 notify，wait 会释放锁，而 notify 不会释放锁。（sleep也不会）
需要注意的是，运用这种方法，必须要保证 t2 先执行，也就是首先让 t2 监听才可以

```
package com.sangyu.test.test23;

import java.util.ArrayList;
import java.util.List;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午10:01
 */
public class Test20 {
    volatile List lists = new ArrayList();
    public void add(Object o){
        lists.add(o);
    }

    public int size(){
        return lists.size();
    }

    public static void main(String[] args) {
        Test20 test20 = new Test20();
        final Object lock = new Object();

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("t2 启动");
                if(test20.size() != 5){
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("t2 结束");
            }
        }).start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("t1 启动");
                synchronized (lock){
                    for(int i =0; i<10;i++){
                        test20.add(new Object());
                        System.out.println("add " + i);
                    }

                    if(test20.size() == 5){
                        lock.notify();
                    }

                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}
```

分析：面试题中我们是 volatile 来解决通知所有线程变量发生变化，但是 volatile 会产生不精确的问题（指的是很有可能在多几个线程出来，给容器继续 add，这个时候打印出来的可能就不是5了），所以我们通过加锁 lock 来解决这个问题

使用 wait 和 notify 必须用 synchronized 锁定 lock，然后调用被锁定对象的 wait 方法和 notify 方法。。

假使现在有一个对象被锁定，有两个线程要访问这个对象。在第一个线程访问的过程中，条件还没有满足，我想让这个线程暂停等着，首先锁定这个对象，这个时候调用这个对象的 wait 方法，当前线程就进入等待状态，同时释放锁，其他线程就可以访问这个对象。什么时候这个线程可以再次启动呢，只有在调用这个对象的 notify 或 notifyall 方法，notify 方法会启动一个正在这个对象等待的某一个线程，或者调用 notifyall 方法叫醒在这个对象上等待的所有线程（是其他线程调用，并不是正在等待的线程调用），所以一定要先启动 t2 线程，再启动 t1 线程，t2 线程在 wait 过程中，t1 满足线程后叫醒 t1 线程

这里还需要考虑一个问题，我们在判断中使用了 if 而不是 while 。这是因为用 if 是因为叫醒一次就可以执行一次关闭，

还要一个问题，为什么只有 t2 执行完了 t1 才会执行这是因为 notify 不释放锁（sleep也不释放锁）notify 不需要指定锁由线程调度器会帮你指定一个线程运行

我们还可以在 t1 线程中，在增加一个 wait 方法，因为 wait 方面可以释放锁。但是我们在执行完 t2 后，还得使用 notify 通知 t1，让 t1 继续执行直到结束，这个过程比较繁琐

![](https://upload-images.jianshu.io/upload_images/2765653-ad0f969254d1a729.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 36. 使用 await 和 countdown

给 lists 增加 volatile 之后，t2 能够接到通知，但是，t2 的死循环很浪费 CPU，如果不用死循环

可以使用 wait 和 notify 做到，wait 会释放锁，而 notify 不会释放锁
需要注意的是，运用这种方法，必须先保证 t2 先执行（就是要监听的线程），也就是首先让 t2 监听才可以。

当我们使用 wait 和 notify 后，t2 会执行使用 wait 通知 t1，t1 执行后使用 notify 通知 t1，但是 t1 不会立刻执行，因为 notify 并不会释放锁，所以 t1 会等到 t2 结束后才执。

还可以使用 Latch(门闩) 替代 wait 和 notify 来进行通知，好处是通信方式简单，同时也可以指定等待时间。

CountDownLatch 不涉及锁定，当 CountDownLatch 的值为零时锁释放当前线程继续运行，调用 countdownm 修改

CountDownLatch 和 wait/notify 比较，当不涉及同步，只是线程通信的时候，用 synchronized + wait、notify 就显得太重了，这时应该考虑 CountDownLatch/cyclicabarrier/semaphore

通知门栓打开后不需要锁定对象，还可以继续往下运行


```
package com.sangyu.test.test23;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * User: pengyapan
 * Date: 2020/3/26
 * Time: 下午10:28
 */
public class Test21 {
    volatile List lists = new ArrayList();

    public void add(Object o) {
        lists.add(o);
    }

    public int size() {
        return lists.size();
    }

    public static void main(String[] args) {
        Test21 test21 = new Test21();
        CountDownLatch latch = new CountDownLatch(1);

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("t2 启动");
                if(test21.size() != 5){
                    try {
                        latch.wait(); // 门闩等待不需要锁定对象
                        // 也可以指定等待时间
                        // latch.await(5000, TimeUnit.MILLISECONDS);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("t2 结束");
            }
        }).start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("t1 启动");
                for(int i = 0; i < 10;i++){
                    test21.add(new Object());
                }

                if(test21.size() == 5){
                    latch.countDown(); // 打开门闩，让t2执行 ，通知门闩打开后不需要锁定对象，还可以继续执行
                }
            }
        }).start();
    }

}
```




