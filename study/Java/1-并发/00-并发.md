##  

### 1 了解并发

在上面的一些程序中，我们看到的都是顺序编程的知识，就是程序中的所有事物在任意时刻都只能执行一个步骤。然后，对于某些问题，如果能够并发地执行程序中的多个部分，则会变得非常方便甚至非常必要。

如果你有一台多处理器的机器，那么就可以在这些处理器之间分布多个任务，从而极大地提高吞吐量。这是使用强有力的多处理器web服务器的常见情况。再为每个请求分配一个线程中，它可以将大量的用户请求分布到多个CPU上。

但是，并发通常是提高运行在单处理器上的程序的性能。这是因为在但处理器上运行的并发程序开销确实比该程序的所有部分都顺序执行的开销大，因为其中增加了所谓上下文切换的代价（从一个任务切换到另一个任务）。表面上看，程序的所有部分当作单个的任务运行好像是开销更小一点，并且可以节省上下文切换的代价。

但还存一个问题就是阻塞。如果程序中的某个任务因为该程序控制范围之外的某些条件（通常是I/O）而导致不能继续执行，那么我就说这个任务或线程阻塞了。如果么有并发，则整个程序都将停止下来，直到外部条件发生变化。

所以，如果用并发来编写程序，那么当一个任务阻塞时，程序中的其他任务还可以继续执行，因此这个程序可以保持继续向前执行。

事实上，从性能的角度看，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义。


实现并发最直接的方式是在操作系统级别使用进程。进程是运行在它自己的地址空间内的自包容的程序。多任务操作系统可以通过周期性地将CPU从一个进程切换到另一个进程，来实现同时运行多个进程。尽管这使得每个进程看起来在其执行过程中都是歇歇停停。进程总是很吸引人，因为操作系统通常会将进程互相个离开，因此它们不会彼此干涉，这使得进程编程相对容易一些。但进程通常会有数量和开销的限制，以避免它们在不同的并发系统之间的可应用性

与此相反的是，像Java所使用的是这种并发系统会共享诸如内存和I/O这样的资源，因此编写多线程程序最基本的困难在于协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。

Java采取了更加传统的方法，在顺序型语言的基础上提供对线程得到支持。在多任务操作系统中分叉外部进程不同，线程机制是在由执行程序表示的单一进程中创建任务。

> 上面的内容中，我们了解了为什么要使用并发，以及要介绍了使用多进程开发和多线程开发这两种方法的不同。在Java开发中一般会使用多线程的方式
>
> 但是我们还要注意的是几点是：  
> 1）在单CPU上使用多任务的程序在任意时刻仍旧只在执行一项工作，因此从理论上讲，肯定可以不用为任何任务编写相同的程序  
> 2）Java的线程机制都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。  

### 39.2 基本的线程机制

> 并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通常使用多线程机制，这些独立任务（也被称为子任务）中的每个都将由执行线程来驱动。
> 
> 一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其自己的CPU一样。其底层机制是切分CPU时间，但通常你不需要考虑它
> 
> 线程模型为编程带来了便利，它简化了在单一程序中同时交织在一起的多个操作的处理。在使用线程时CPU将轮流给每个任务分配其占用时间。每个任务都觉得自己在一直占用CPU，但事实上CPU时间是划分称片段分配给了所有的任务（例外情况下程序确实运行在多个CPU之上）
>
> 线程的一大好处是可以使你从这个层次抽身出来，即代码不必直到它是运行在具有一个还是多个CPU的机器上。所以，使用线程机制是一种建立透明的、可扩展的程序的方法。如果程序运行得太慢，为机器增添一个CPU就能很容易地加快程序的运行速度。多任务和多线程往往是使用多处理器系统的最合理方式


### 39.3 使用Runnable接口创建任务

> 线程可以驱动任务，因此需要一种描述任务的方式，可以有Runnable接口来提供
>
> 要想定义任务，只需实现Runnable接口并编写run()方法
>
> Thread.yield(); 将CPU从一个线程转移给另一个线程。它的声明表示：线程已经执行完生命周期中最重要的部分了，此刻正式切换给其他任务执行一段时间的大好实际。

```java
public class LiftOff implements Runnable{
    private int countDown = 10;
    private static int taskCount = 0;
    private final int id = taskCount++;
    
    public LiftOff(){}
    
    public liftOff(int countDown){
        this.countDown = countDown;
    }
    public String status(){
        return "#" + id + "(" + (countDown > 0 ? countDown : "LiftOff!") + ")";
    }   
    
    // 实现run方法
    // 设定跳出循环的条件，停止run()方法
    public void run(){ 
        while(countDown >= 0){
            Sytemt.out.println(status());
            countDown--;
            Thread.yield(); 
        }
    }   
}
```

> run()方法在main()方法中调用（普通方法的调用，并非线程的启动）。（注意，main()也是一个线程）

```java
public class MainThread{
    public static void main(String[] args){
        LiftOff liftOff = new LiftOff();
        liftOff.run();
    }

}
```

> 使用Tread来驱动LiftOff对象，启动任务
>
> Thread构造器只需要一个Runnable对象。调用Thread对象的start()方法为该线程执行必需的初始化操作，启动新的线程并自动调用run()方法。并且启动新的线程后，并不影响main()线程的执行。因此启动新的线程后，main()机组执行。

```java
public class BasicThreads{
    public static void main(String[] args){
        Thread t = new Thread(new LiftOff());
        t.start();
        System.out.println("Waitting for LiftOff");
    }
}
```

> 启动更多的线程去驱动更多的任务
> 
> 这里要了解下：每个Thread都注册了自己，因为确实有一个对它的引用，而且在它的任务退出其run()并死亡之前，垃圾回收器无法清除它。因此一个线程会创建一个单独的执行线程，在对start()的调用完成止呕胡，它仍旧会继续存在

```java
public class BasicThreads{
    public static void main(String[] args){
        for(int i = 0; i < 5;i++){
            new Thread(new LiftOff()).start();
        }
        System.out.println("Waitting for LiftOff");
    }
}
```

### 39.4 使用Exeutor

> JavaSE5的java.util.concurrent包中的执行器（Exeutor）将为你管理Thread对象。从而简化了并发编程。
>
> Exeutor为客户端和任务执行之间提供了一个间接层（这里的客户端指的是直接启动线程），与客户端直接执行任务不同，这个中介对象将执行任务
>
> Exeutor允许你管理异步任务的执行，而无须显示地管理线程的生命周期。Exeutor在JavaSE5/6中是启动任务的优先方法

使用Exeutor来替代显示的创建Thread对象。ExeutorService（具有服务生命周期的Exeutor。例如关闭）知道如何创建恰当的上下文来执行Runnable对象。

注意，ExeutorService对象是使用Exeutor方法创建的

```java
public class CachedThreadPool{
    public static void main(String[] args){
        ExeutorService exec = Exeutors.newCachedThreadPool();
        for(int i = 0; i < 5; i++){
            exec.execute(new LiftOff());
        }
        exec.shutdown();
    }
}
```

在上面的例子中，我们通过Exeutors创建ExeutorService，并通过execute来创建和管理系统中的所有的任务

对shutdown()方法的调用可以防止新任务被提交给Exeutor，在main()线程启动后，将运行提交的所有任务，在调用shutdown()之前

> 下面我们将newCachedThreadPool替换为newFixedThreadPool，使用有限的线程集来执行所提交的任务

```java
public class CachedThreadPool{
    public static void main(String[] args){
        ExeutorService exec = Exeutors.newFixedThreadPool(5);
        for(int i = 0; i < 5; i++){
            exec.execute(new LiftOff());
        }
        exec.shutdown();
    }
}
```

在上面的例子中，我们通过使用newFixedThreadPool一次性预先执行代价高昂的线程分配，因为也就可以限制线程的数量了。这样可以节省时间，因为你不用为每个任务都固定得付出创建线程的开销

要注意：在任何线程池中，现有线程在可能的情况下，都会被自动复用

> 继续了解下singleThreadExecutor 就像是线程数量为1的newFixedThreadPool。这对于如果希望在另一个线程中连续运行的事物来说，都是很有用的，例如更新本地或远程日志的小任务。

> 如果向singleThreadExecutor提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前运行结果，所有的任务将使用相同的线程。
>
> 因此向singleThreadExecutor会序列化所有提交给它的任务，并会维护它自己（隐藏）的悬挂任务队列

```java
public class SingleThreadExecutor{

    public static void main(String[] args){
        ExeutorService exec = Exeutors.newSingleThreadExecutor();
        for(int i= 0; i < 5;i++){
            exec.execute(new LiftOff());
        }
         exec.shutdown();
    }   
}
```

### 39.5 从任务中产生返回值

> Runnable是执行工作的独立任务，但是它不返回任何值，如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口。
>
> 在JavaSE5中引入Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call()（而不是run(）中返回的值，并且必须使用ExcutorService.submit()方法调用它

```java
class TaskWithResult implements Callable<String>{
    private int id;
    public TaskWithResult(int id){
        this.id = id;
    }
    public String call(){
        return "Result od TaskWithResult " + id;
    }
}

public class CallableDemo{
    public static void main(String[] args){
        ExeutorService exec = Exeutors.newCachedThreadPool();
        ArrayList<Future<String>> results = new ArrayList<Future<String>>();
        for(int i = 0; i< 10;i++){
            results.add(exec.submit(new TaskWithResult(i)));
        }
        for(Future<String> fs:results){
            try{
                System.out.println(fs.get);
            }catch(InterruptedException e){
                System.out.println(e);
                return;
            }catch (ExecutionException e){
                System.out.println(e);
            }finally{
                exec.shutdowm();
            }
        }
    }
}
```

在上面的例子中submit()方法会产生Future对象，它用Callable返回结果的特定类型进行了参数化。

可以使用isDone()方法来查询Future是否已经完成。

当任务完成时，它具有一个结果，你可以调用get()方法来获取该结果。

也可以不同isDone()进行检查就直接调用get()。在这种情况下，get()将阻塞，直到结果准备就绪。所以可以在试图调用get()之前，先调用具有超时的get()或者调用isDone()来查看任务是否完成

### 39.6 休眠

> 影响任务行为的一种简单方法是调用sleep()，这将使任务中止执行给定的时间

```java
public class SleepingTask extends liftOff{
    public void run(){
        try{
            while(countDown >0){
                System.out.println(status());
                TimeUnit.MILLISECONDS.sleep(100);
            }
        }catch (InterruptedException e){
            System.out.println("Interrupted");
        }
    }
    public static void main(String[] args){
    
        ExecutorService exec = Exectors.newCacedThreadPool();
        for(int i = 0;i<5;i++){
            exec.execute(new SleepingTask());
        }
        exec.shutdown();
    }   

}
```

要注意的是，对sleep()的调用可以抛出InterruptedException的异常，因为异常不能跨线程传播回main()，所以你必须在本地处理所有在任务内部产生的异常

使用sleep()延迟后，每个任务都将要睡眠在执行打印语句之后，这使得线程调度器可以切换到另一个线程，进而驱动另一个任务。


### 39.7 优先级

> 线程的优先级将该线程的重要性传递给了调取器，尽管CPU处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先级最高的线程先执行。然后这并不意味着优先级较低的线程将得不到执行（也就是说，优先级不会导致死锁）。优先级较低的线程仅仅是执行的频率较低
>
> 在大多数的时间里，所有线程都应该以默认的优先级运行。
>
> 可以使用getPriority()来去读现有线程的优先级，并且在任何时刻都可以通过setPriority()来修改它

```java
public class SimplePriorities implements Runnable{
    private int countDown = 5;
    private volatile double d;
    private int priority;
    public SimplePriorities(int priority){
        this.priority = priority;
    }
    public String toString(){
        return Thread.currentThread() + ": " + countDown;
    }
    public void run(){
        Thread.currentThread().setPriority(priority);
        while(true){
            for (int i = 1;i<10000;i++){
                d += (Math.PI + Math.E);
                if (i % 1000 == 0){
                    Thread.yield();
                }
            }
            System.out.println(this);
            if((--countDown )== 0){
                return;
            }
        }
    }
    public static void main(String[] args){
        ExecutorService exec = Exectors.newCacedThreadPool();
            for(int i = 0;i<5;i++){
                exec.execute(new SimplePriorities(Thread.MIN_PRIORITY));
                exec.execute(new SimplePriorities(Thread.MAX_PRIORITY));
            }
            exec.shutdown();
    }

}
    
```

在上面的例子中，toString()方法被覆盖，以便使用Thread.toString()方法来打印线程的名称，线程的优先级以及线程所属的线程组

通过调用Thread.currentThread()来获得对驱动该任务的Thread对象的引用。

### 39.8 让步

完成了在run()方法后，就可以高度线程调度机制：工作完成的差不多了，可以让别的线程使用CPU了。这个过程也可以通过用yield()方法来通知(这只是一个通知，没有任何机制保证它将会被采纳)，当调用时，也可以建议具有相同优先级的其他线程可以运行

### 39.9 后台线程

所有后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程。

反过来说，只要有任何非后台线程还在运行，程序就不会终止。比如，执行main()就是一个非后台线程

### 39.10 继承Thread创建任务

## 四十、共享受限资源

可以把单线程程序当作在问题域求解的单一实体，每次只能做一件事情。因为只有一个实体，所以永远不会担心"两个实体视图同时使用同一资源"这样的问题。比如，两个个人在同一个地方停车，两个人同时走过一扇门，甚至是两个人同时说话

有了并发就可以同时做多件事情了，但是，两个或多个线程彼此互相干涉的问题也就出现了。如果不防范这种冲突，就可能发生两个线程同时视图访问同一个银行账户，改变同一个值等诸如此类的问题

### 40.1 不正确地访问资源

