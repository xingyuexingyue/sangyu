![](https://upload-images.jianshu.io/upload_images/2765653-c3d3890148636826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


```isAlive()```判断线程是否或者，即线程是否还未终止

```getPriority()``` 获得线程的优先级数值

```setPriority()``` 设置线程的优先级数值

```Thread.sleep()``` 将当前线程睡眠指定毫秒数，不会释放锁

```join()``` 调用某线程的该方法，将当前线程与该线程合并，即等待该线程结束，再恢复当前线程的运行

```yield()``` 让出CPU，当前线程进入就绪队列等待调度 释放锁

```wait()```当前线程进入对象的wait pool 会释放锁

```notify()``` 唤醒对象的wait pool中的一个等待线程

```notifyAll() ``` 唤醒对象的wait pool中的所有等待线程

## 线程的生命周期

线程并非创建后就立马执行，使用 new 创建了线程后，线程进入了新建状态，调用 start() 方法后进入就绪状态，此时要等待 CPU 调度器分配时间片段给线程，CPU 开始处理后，进入运行状态，正常执行完 run() 方法后进入死亡状态，如果运行中调用 sleep() 或 wait() 方法会进行阻塞状态直到重新进行就绪状态，就是休眠时间结束或者 notify 通知后

1. 新建状态（ new ）

当线程被创建时，它会短暂地处于这种状态，此时已经分配了系统资源，并执行初始化，此时线程已经有资格获得 CPU 时间了，之后调度器将把这个线程转变为就绪状态或阻塞状态

用 new 创建一个线程

2. 就绪状态 ( Runnable ）

在这种情况下只要调取器把时间片分配给线程，线程就可以下运行

调用了 start() 方法之后

3. 运行状态（ Running ）

线程正在执行

4. 阻塞状态（ Blocked ）

线程能够运行，但有某个条件组织它运行。当处于阻塞状态时，调度器将忽略线程，不会分配给线程 CPU 时间，只有进入就绪状态才能执行

进入阻塞状态的原因：

1）sleep() 进入休眠状态，等待休眠时间结束

2）wait() 线程挂起，直到调用 notify() 或 notifyAll() 才会进入就绪状态

3）任务试图在某个对象上调用其同步方法，但是对象锁不可用，因为另一个任务已经获取了这个锁

5. 线程死亡（Dead)

处于死亡或终止状态的线程将不再是可调度，任务已结束。

run() 或 call() 执行完成 正常结束

抛出未捕获的 Exception 或 Error 异常结束
