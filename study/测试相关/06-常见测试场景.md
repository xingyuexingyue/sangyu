## 1. 异步系统的两种测试方法

**先清楚异步和同步的概念**

同步调用：调用方在调用过程中，持续等待返回结果。
异步调用：调用方在调用过程中，不直接等待返回结果，而是执行其他任务，结果返回形式通常为回调函数。

**编写一个调用异步方法的小程序**

1) AsyncCall类中call()方法是一个异步方法，接收BaseDemo类型的参数，并调用BaseDemo的callback返回调用结果
2) BaseDemol类call()发起对AsyncCall类的异步方法的调用，还有一个抽象方法callback需要每个继承BaseDemol类的子类去实现
3) MyDemo类继承了BaseDemol类并实现了callback()方法，在它的main方法中我们调用了AsyncCall的异步方法，从运行结果可以看出，调用后先主线程内容会紧随调用内容立刻打印，回调方法调用打印返回结果

```java
package com.sangyu.test.test28;

import java.util.Random;

/**
 * 异步调用类
 * User: pengyapan
 * Date: 2020/4/13
 * Time: 下午1:03
 */
public class AsyncCall {

    private Random random = new Random(System.currentTimeMillis());
    
    /**
     * 这个方法接收了一个demo参数，并且开启了一个线程，在线程中执行具体的任务，并利用demo的callback方法进行回调函数的调用。
     * @param demo
     */
    public void call(BaseDemo demo){

        new Thread(()->{
            long res = random.nextInt(10);

            try {
                Thread.sleep(res*1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            demo.callback(res);
        }).start();


    }
}
```

```java
package com.sangyu.test.test28;

/**
 * User: pengyapan
 * Date: 2020/4/13
 * Time: 下午1:06
 */
public abstract class BaseDemo {

    protected AsyncCall asyncCall = new AsyncCall();

    public abstract void callback(long response);

    public void call(){
        System.out.println("发起调用");
        asyncCall.call(this); // 调用异步方法call()
        System.out.println("调用返回");
    }
}
```

```java
package com.sangyu.test.test28;

/**
 * User: pengyapan
 * Date: 2020/4/13
 * Time: 下午2:21
 */
public class MyDemo extends BaseDemo{

    @Override
    public void callback(long response) {
        System.out.println("得到结果");
        System.out.println(response);
        System.out.println("调用结束");
    }
    public static void main(String[] args) {
        MyDemo myDemo = new MyDemo();
        myDemo.call();
        System.out.println("主线程内容");
    }
}
```

对于实时性要求不高，但却计算密集或者需要处理大数据量的耗时较长的任何，选择异步化是一个不错的选择。在系统层面，像引入消息中间件来解耦系统，将耗时长的任务放在中间件后异步执行。在方法层面，像把耗时较长的任务放到其他线程中去异步执行。

与测试同步系统或方法不同，当我们测试异步系统（端到端测试、集成测试）或异步方法的时候（单元测试），由于测试线程不会被异步任务线程阻塞而让测试变得不可控，概率性失败，以单元测试为例，这样写异步测试是不稳定的：

```
@Test
public void testAsynchronousMethod() {
    callAsynchronousMethod();
    assertXXX(...);  //异步任务可能仍未完成，这时assert可能会失败
}
```

**异步任务的两种类型**

- 异步任务执行后对任务发起方或调用方有感知，比如发出一个事件或通知
- 异步任务执行后对任务发起方或调用方没有感知，只是改变了系统中的某些状态

对异步任务的测试也分以上两种类型讨论。对于第一种，我们可以采用监听方式测试，还是使用刚刚的例子，我们稍加处理，AsyncCall类和BaseDemol类不需要改变，只需要修改MyDemo，在主线程利用wait进行阻塞，等待回调中调用notify或者notifyAll方法来进行唤醒。注意，和大家认知的一样，这里wait和notify都是需要先获得对象的锁的。

```java
public class MyDemo extends BaseDemo{
    private final Object lock = new Object();

    @Override
    public void callback(long response) {
        System.out.println("得到结果");
        System.out.println(response);
        System.out.println("调用结束");

        synchronized (lock) {
            lock.notifyAll();
        }

    }

    public static void main(String[] args) {

        MyDemo myDemo = new MyDemo();

        myDemo.call();

        synchronized (myDemo.lock){
            try {
                myDemo.lock.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("主线程内容");

    }
}
```

我们测试时会可能会借助测试框架testNG或Junit，所以上面代码我们可以在修改适合测试框架的：

```java
import org.junit.Before;
import org.junit.Test;

public class ExampleTest {
    private final Object lock = new Object();

    @Before
    public void init() {
        new Thread(new Runnable() {
            public void run() {
                synchronized (lock) {  //获得锁
                    monitorEvent();    //监听异步事件的到来
                    lock.notifyAll();  //事件到达，释放锁
                }
            }
        }).start();
    }

    @Test
    public void testAsynchronousMethod() {
        callAsynchronousMethod();  //调用异步方法，需要较长一段时间才能执行完，并触发事件通知

        /**
         * 事件未到达时由于init已经获得了锁而阻塞，事件到达后因init中的锁释放而获得锁，
         * 此时异步任务已执行完成，可以放心的执行断言验证结果了
         */
        synchronized (lock) {
            assertTestResult();
        }
    }
}
```

上面的例子，前提是事件通知会到来并被监听到，如果一直调用方产生异常一直没有回调那我们如何处理？按照上面的逻辑，会一直等待收到回调后才能继续执行用例，显然这是不现实的

我们可以通过引入超时机制，这也是我们上面第二种类型的异常测试（可以称之为轮询方式）

假如我们现在有一个异步系统，应用发消息到消息中间件，一个待测试的 Job 监听这个消息并在消息到达后处理消息：

![](https://upload-images.jianshu.io/upload_images/2765653-4cf5ad7b6bccdd0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这也是常见的消息队列模式，生产者和消费者模式，我们现在要思考如果测试这种异步系统，实际也是测试消息队列中生产者和消费者不同身份，如果我们是生产者就要思考保证生产的消息放到消息队列以及它的正确性，如果我们是消费者要思考监听到消息后，从消息队列中取出数据以及后续处理逻辑正确性

这里我们可以借助于awaitility 工具类，验证消费者对生产者的消息处理逻辑正确性

```
@Test
public void testAsynchronousJob() throws Exception {
    String msg = buildNsqMsg();    //构造NSQ消息
    nsqClient.send(TOPIC, msg, false);	//发送Nsq消息

    with().pollInterval(ONE_HUNDRED_MILLISECONDS).  //100ms后开始检查
            and().with().pollDelay(10, MILLISECONDS).  //此后每隔10ms检查一次
            await("description").  //描述信息
            atMost(1L, SECONDS).   //1s超时时间
            until(() -> xxxService.getState() == "changed");  //业务相关的断言逻辑
}
```



**分析两种测试结果可靠性问题**

使用异步轮询的过程中，在两次轮询中间系统状态因为某些原因出现了抖动，下一次轮询时轮询方式可能会误以为异步操作还未完成或出现了异常，从而导致测试结果误判：

![](https://upload-images.jianshu.io/upload_images/2765653-39600bbb13d03b12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

但监听方式是不存在这样的问题的，只要系统状态改变，监听中的测试能立马感知到，并作出可靠的测试结果

![](https://upload-images.jianshu.io/upload_images/2765653-e03ea6b2e4613797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

很多异步系统对外是没有回调的，这时候只能依靠轮询方式测试异步任务，而轮询测试结果的可靠性取决于待测系统的可靠性

## 2. 必测的支付漏洞

#### 2.1 使用fiddler篡改支付金额

使用抓包工具fiddler4修改支付金额，fiddler能把网页拦截，修改服务器返回参数，并把修改后的数据包发送给服务器

1. 拦截订单网页
1) 在下方命令行输入命令:bpu +网页域名

2) web app端点击提交订单，出现图中红色标识，网页已拦截

2. 修改订单价格

![](https://upload-images.jianshu.io/upload_images/2765653-19dca78d4e1fe1aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1) 选中拦截的链接，右侧菜单选择Inspectors--WebForms

2) 修改参数totalPrice，这里的8.8是电子书价格，此处修改为0.02

3) 点击Run to Completion，发送修改后参数

3. 跳转到付款页面

![](https://upload-images.jianshu.io/upload_images/2765653-c5a0de2550e17451.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

点击继续支付，跳转到支付宝界面，如图，已修改为0.02元，成功篡改支付金额！

#### 2.2 支付流程 "幂等性"

幂等性其实是源于数学，后来延伸到计算机领域。是指可以使用相同参数重复执行，并能获得相同结果的函数，这些函数不会影响系统状态， 也不用担心重复执行对系统造成改变。其实，幂等性指的是一次和多次请求某一个资源应该具有同样的作用

我们先从一个例子说起，假设有一个从账户取钱的远程API，我们暂时用类函数的方法记为：

bool withdraw(account_id,amount)

withdraw的语义从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false， 账户余额。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被丢掉了，导致客户端无法得知处理结果。如果是网页上， 一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面， 这样withdraw被调用两次，账号也被多扣了一次钱。如下图所示：

![](https://upload-images.jianshu.io/upload_images/2765653-abd4e535ff5b8fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们可以通过一些技巧把withdraw变成幂等的，比如：

```
int create_ticket()
bool idempotent_withdraw(tickeet_id,account_id,amount)`
```
create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。 idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会 被处理一次，每次调用都将返回第一次调用时的处理结果。这样idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。

基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：

1. 调用create_ticket()获取ticket_id

2. 调用idempotent_withdraw(tickeet_id,account_id,amount)。虽然create_ticket不是幂等的，但是这种设计下， 它对系统状态的影响可以忽略，加上(tickeet_id,account_id,amount)是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果 ，如下图所示：

![](https://upload-images.jianshu.io/upload_images/2765653-a30b3a60a8861181.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上面的例子是关于幂等性思想在取款流程的体现，其实支付是相似的。在取款流程中，服务器会生成一个唯一处理号ticket_id，而在支付流程中，会在提交 订单时生成一个订单编号prepay_id，也叫预支付id。如果一个订单支付成功后，在支付页面(如下图)再次进行支付，应提示"该订单已支付"的提示。这就是 幂等性在支付流程中的体现，同一个订单的操作只会进行一次，订单支付成功后，客户端尝试再次支持，此时会带着prepay_id进行请求，服务器会返回第一次支付 请求的处理结果，所以同一个订单不会进行多次支付

![](https://upload-images.jianshu.io/upload_images/2765653-fdbf2b1ecfd3ab9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

还有一种情况，就是提交订单，选择支付方式，跳转到支付宝二维码页面时，断掉网络，扫描二维码，进行支付。支付成功后， 再次扫描二维码，看看会给出怎样的提示？我扫出的结果如下，提示我：该订单已支付，也印证了"幂等性"的思想，一次请求和多次请求 具有相同的结果。

![](https://upload-images.jianshu.io/upload_images/2765653-4eccd2a907b16d60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 2.3 服务器未返回支付结果前进行干预

首先，回顾一下支付的流程如下：

1. 提交订单。选好商品、数量后，点击"提交订单"按钮，跳转到选择支付方式页面

![](https://upload-images.jianshu.io/upload_images/2765653-4f35249b7a8c963e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2. 选择支付方式

3. 进行支付

![](https://upload-images.jianshu.io/upload_images/2765653-569d0bab5621cd73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

4. 服务端返回支付结果，客户端显示

在这个过程中，可以进行如下测试：

1) 选择完支付方式、跳转到支付页面后，查看"我的订单"，此时显示"待支付"状态

![](https://upload-images.jianshu.io/upload_images/2765653-44de43ece7b3d2da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2) 然后断掉网络，扫描支付宝二维码进行支付；支付成功后，连上网络，刷新"我的订单"页面，查看订单状态，是否是"已支付"状态

![](https://upload-images.jianshu.io/upload_images/2765653-a96b0eb895989854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

3) 如果是未支付状态，则是有问题的。一般来说，如果因为网络原因，服务端没有把支付完成的消息实时反馈给客户端，应进行多次请求，直到客户端接收到支付结果

4) 如果客户端不是网页，而是手机APP，可以在输完支付密码后，立即关闭APP的进程，然后再启动APP，查看"我的订单"中的状态，是否是"已支付"状态







