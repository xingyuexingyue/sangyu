##### mock 的优点

1. 团队可以并行工作

前后端人员只需要定义好借口文档就可以开始并行工作，互不影响，后端与后端之间如果有接口耦合，也同样能被Mock解决；测试过程中如果遇到依赖接口没有准备好，同样可以借助Mock；不会出现一个团队等待另一个团队的情况。这样的话，开发自测阶段就可以及早开展，从而发现缺陷的实际也提前了，有利于整个产品质量以及进度的保证

2. 测试驱动开发

单元测试是TDD实现的基石，而TDD经常碰到协同模块尚未开发完成的情况，但是有mock，这些一切都不是问题。当借口定义好后，测试人员就可以创建一个Mock，把接口添加到自动化测试环境，提前创建测试

3. 可以模拟哪些无法访问的资源

比如说，需要调用一个墙外的资源来方便自己调试，就是自己mock一个

4. 隔离系统

加入我们需要调用一个post请求，为了获得某个响应，来看当前系统是否能正确处理返回的响应，但是这个post请求会造成数据库数据的污染，那么就可以充分利用mock，构造一个虚拟的post请求，给它指定返回就好了

5. 减轻测试执行难度

假如有一个接口，有100个不同类型的返回，我们需要测试它在不同返回下，系统是否能够正常响应，但是有些返回在正常情况下基本不会发生，比如，我们需要测试在当接口发生500错误的时候，app是否崩溃，需要服务器代码返回500。而使用mock，就可以模拟这种情况了

##### mock 风险

无法体现真实的测试环境

1. 性能测试，对于接口的依赖，把代码需要运行的时间忽略而过，资源创建和销毁没有被体现

2. 多重假设导致功能出现故障的概率大大增加，测试和回归都是如此

3. 执行用例时候，因为使用的都是mock无法发现真是的问题，使测试失真

4. 代码往往牵一发而动全身，有时候mock，不如不mock，如退款，需要先在数据库中插入支付信息等，构造繁琐


##### mock 模拟器对比


##### Mitmproxy工具

对比Moco工具的优势

1. Mock为服务器部署，需要单独占用服务器资源，而Mitmproxy为本地部署，直接本地mock无需单独占用服务器
2. mock需要在服务端编辑json文件进行。这个文件配置过程中只要有一个符号或者标点出错，moco服务是启动不了的
moco需要服务端请求，请求返回的快慢完全取决于服务器的响应速度，但是Mitmproxy却不需要，因为是本地mock数据，响应速度就是快

https://mitmproxy.org/