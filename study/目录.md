
# 了解抽象思想

[一、抽象思想 ](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%80%E6%8A%BD%E8%B1%A1%E6%80%9D%E6%83%B3)

面向对象思想的实质是：程序可以通过新类型的对象使自身适用于某个特定的问题。

[三、理解对象](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1)

我们介绍如何创建类和对象。类提供了一个模版，然后基于类的模版创建不同的对象。

当我们在开发或理解一个程序设计时，最好的方法之一就是将对象想象为"服务的提供者"， 对于用户来说，程序本身就是向用户提供服务，对于程序来说，它是通过调用不同的对象提供的服务来 实现这一目的的

# 介绍类

[二、创建对象和方法](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95)

每个类属于一种类型，通过关键字class来创建类，引入新的类型，通过类来创建对象，每个对象拥有类的属性和方法，并且每个对象都是唯一的

```java
/**
* 1、创建一个名为Light的类
* 通过class关键字，后面紧跟着的是class的名称
* 类名的首字母必须大写
*/
public class Light {
    // 代码块...
}
```

Java 一切都是对象，但我们操作的标识符实际上是对象的一个引用

```java
/**
* 创建类的对象
*/
public class Test{
    /**
    * 1、创建Light类的对象且名称为：light
    */
    public static void main(String[] args){
        Light light = new Light();
        // 2、调用这个对象的方法
        // 用引用来操纵对象
        light.on(); 
        light.off();
    }
}
```
[五、介绍三个关键字：public、private、protected](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%94%E4%BB%8B%E7%BB%8D%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97publicprivateprotected)

1）public ： 对于任何人都是可用的

2）private ：除类型的创建者和类型的内部方法之外的任何人都不能访问

3）protected ：继承类可以访问

[七、继承](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%83%E7%BB%A7%E6%89%BF)

当我们继承现有类时，也就创建了新的类，这个类不仅包括了现有类的所有成员， 和方法（现有类中的private成员和方法不可访问）。

[九、final关键字](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B9%9Dfinal%E5%85%B3%E9%94%AE%E5%AD%97)

final会使用到的三种情况：数据、方法和类

final数据：

1）一个永不改变的编译时常量

2）一个在运行时被初始化的值，而你不希望它被改变

对于编译期常量这种情况，在Java中，这类常量必须是基本数据类型，以关键字final修饰。在对这个常量进行定义的时候，必须对其进行赋值。

一个既是static又是final的域只占据一段不能改变的存储空间，用大写表示，并使用下划线分隔各个单词

[十、多态](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E5%8D%81%E5%A4%9A%E6%80%81)

多态的作用是消除类型之间的耦合关系。

继承允许将对象视为它自己本身的类型或其父类型来加以处理。 允许将多种类型（从同一父类继承的）视为同一类型来处理。 多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一父类继承而来的。 这种区别是根据方法行为的不同而表现出来的，虽然这些方法都可以通过同一父类来调用

[十一、后期绑定、向上转型的概念](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E5%8D%81%E4%B8%80%E5%90%8E%E6%9C%9F%E7%BB%91%E5%AE%9A%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5)

向上转型：因为动态绑定，所以发送给父类的任何消息，子类都可以接收，那么将子类看作是它的父类的过程称为向上转型。

为了执行后期绑定，Java使用了一段特殊的代码替代绝对地址调用。这段代码使用在对象存储的信息来计算方法体的地址。 这样，根据这一小段代码的内容，每个对象都可以具有不同的行为表现，当向一个对象发送消息时，该对象就能知道对这条消息应该做些什么。 在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态

[十二、Object类](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E5%8D%81%E4%BA%8Cobject%E7%B1%BB)

在Java中所有的类最终都继承自单一的基类，这个类就是Object，这称为单根继承结构

[十七、作用域](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E5%8D%81%E4%B8%83%E4%BD%9C%E7%94%A8%E5%9F%9F)

作用域决定了在其内定义的明亮名的可见性和生命周期，在Java中，作用域由花括号的位置决定

[十八、equals()重写](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E5%8D%81%E5%85%ABequals%E9%87%8D%E5%86%99)

[二十、用构造器确保初始化](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E7%A1%AE%E4%BF%9D%E5%88%9D%E5%A7%8B%E5%8C%96)

在Java中，通过构造器，可以确保每个对象都会得到初始化。 创建对象时，如果类具有构造器，Java就自动调用相应的构造器，从而保证了初始化的进行。

构造器的命名：构造器采用与类相同的名称 这里要注意的是，构造器的名称必须与类名完全相同，所以每个方法首字母小写的规则并不适用于构造器

[二十一、方法重载](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E4%B8%80%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD)

在Java里，构造器的强制重载方法名的另一个原因。既然构造器的名字已经由类名所决定，就只能有一个构造器名， 如果想用多种方式创建一个对象怎么办呢？这就需要两个构造器：一个默认构造器，另一个带有参数的构造器。由于都是 构造器，所以它们必须有相同的名字，即类名。为了让方法名相同而形式参数不同的构造器同时存在，必须用到方法重载。 同时，尽量方法重载是构造器所必须的，但也可应用于其他方法，且用法同样方便。

[二十一、this关键字](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E4%B8%80this%E5%85%B3%E9%94%AE%E5%AD%97)

如果想在方法内部获得当前对象的引用。可以通过this关键字， this 关键字只能只能在方法内部使用，表示对"调用方法的那个对象"的引用。但要注意的是：如果在方法内部调用 同一个类的另一个方法，就不必使用this，直接调用即可。当前方法中的this引用会自动应用于同一个类中的其他方法

[二十二、static 含义](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E4%BA%8Cstatic-%E5%90%AB%E4%B9%89)

static 方法（静态方法）就是没有this的方法。在static方法的内部不能调用非静态方法，反过来是可以的。 而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。

[二十三、成员初始化](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E4%B8%89%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96)

Java 尽力保证：所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，必须在使用时为变量赋一个默认值， 否则编译器会报错

对于类的数据成员（即字段）是基本类型，如果定义是没有初值，编译器也会给一个初始值，如果是在类里定义一个 对象引用时，如果不将其初始化，此引用就会获得一个特殊值null

[二十四、构造器初始化](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E5%9B%9B%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96)

可以用构造器来进行初始化，在运行时刻，可以调用方法或执行某些工作来确定初值，但要牢记：无法 组织自动初始化的进行，它将在构造器之前被调用之前发生。

[二十五、静态数据的初始化](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E4%BA%94%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96)

无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量。因此它只能作用于域。

[二十六、对象的创建过程*](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E5%85%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B)

[二十七、显示的静态初始化](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E4%B8%83%E6%98%BE%E7%A4%BA%E7%9A%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96)

[二十八、非静态实例初始化](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E5%85%AB%E9%9D%9E%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96)

[三十、可变参数列表](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E5%8D%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8)

JavaSE5增加的新特性，可以使用它们来定义可变参数列表


# 了解枚举

[三十一、枚举类型](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E5%8D%81%E4%B8%80%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B)

枚举类的语法：由于枚举类型的实例是常量，因此按照命名惯例它们都用大写字母表示（如果一个名字中 有多个单词，用下划线将它们隔开）

# 了解抽象类和方法和接口

[三十二、抽象类和抽象方法](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E5%8D%81%E4%BA%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95)

定义抽象方法，仅有声明而没有方法体，比如abstract void f();，包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的

[三十三、接口](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E5%8D%81%E4%B8%89%E6%8E%A5%E5%8F%A3)

interface关键字产生一个完全抽象的类，方法不提供任何具体实现。它允许创建者确定方法名、参数列表、返回类型， 但是没有任何方法实现。接口只提供了形式，而未提供任何具体实现

# 了解条件判断和循环

[十九、控制执行流程](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E5%8D%81%E4%B9%9D%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B)

就像有知觉的生物一样，程序必须在执行过程中控制它的世界，并做出选择。在Java中，要使用执行控制语句来做出选择。

在Java中，控制语句涉及的关键字包括if-else、while、do-while、for、return、break以及选择语句switch。

# 了解容器

[十三、容器](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E5%8D%81%E4%B8%89%E5%AE%B9%E5%99%A8)

创建一种对象类型。这种新的对象类型持有其他对象的应用。这个通常通常被称为容器

Java中具有满足不同需要的各种类型的容器，List（用于存储序列），Map（用来建立对象之间的关联），Set（每中对象类型只持有一个），以及诸如队列、树、堆栈等更多的构件

# 了解泛型

[十四、泛型](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E5%8D%81%E5%9B%9B%E6%B3%9B%E5%9E%8B)

创建容器时，就确定要容器要保存的对象的类型，从而不需要向下转型以及消除犯错误的可能。这种解决方案被称为参数化类型机制。一对尖括号，中间包含类型信息，通过这些特征就可以识别对泛型的使用 ArrayList<Shape> shapes = new ArrayList<Shape>();

# 了解数组

[二十九、数组初始化](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8D%81%E4%B9%9D%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96)

数组只是相同类型的、同一标识符名称封装到一起的一个对象序列或基本类型数据序列。

数组是通过方括号下标操作符[]来定义和使用的。 要定义一个数组，只需在类型名后加上一对空方括号即可int[] a1，方括号也可以置于标识符后面int a1[]

# 操作符

[四、操作符](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E5%9B%9B%E6%93%8D%E4%BD%9C%E7%AC%A6)

# 了解数据类型

[十六、数据类型](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E5%8D%81%E5%85%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)

# 了解内部类

[三十四、内部类](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E5%8D%81%E5%9B%9B%E5%86%85%E9%83%A8%E7%B1%BB)

# 了解字符串

[三十五 字符串](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E5%8D%81%E4%BA%94-%E5%AD%97%E7%AC%A6%E4%B8%B2)

String是不可变的，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动

# 了解异常

[三十六、异常](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E5%8D%81%E5%85%AD%E5%BC%82%E5%B8%B8)

Java异常是Java提供的用于处理程序中错误的一种机制。所谓错误是指在程序运行的过程中发生的一些异常事件（如：除0溢出，数组下标越界，所要读取的文件不存在）**并非在编写代码出现的编译时错误（注意：发生异常时，观察错误的名字和行号最重要），设计良好的程序应该在异常发生时提供处理这些错误的方法，使得程序不会因为异常的发生而阻断或产生不可遇见的结果。

# 了解反射

[三十七、Java- Class.forName() 和 Xxx.class](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E5%8D%81%E4%B8%83java--classforname-%E5%92%8C-xxxclass)

[三十八、Java - 反射机制（reflction）](https://github.com/xingyuexingyue/sangyu/blob/master/study/Java%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E5%8D%81%E5%85%ABjava---%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6reflction)
